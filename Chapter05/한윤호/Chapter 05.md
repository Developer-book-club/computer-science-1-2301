# 자료구조(data structure)
효율적으로 데이터를 관리하고 수정, 삭제, 탐색, 저장할 수 있는 데이터 집합을 말합니다.

# 복잡도
복잡도는 시간 복잡도와 공간 복잡도로 나뉩니다.

## 시간 복잡도
시간 복잡도란 '문제를 해결하는 데 걸리는 시간과 입력의 함수 관계'를 가리킵니다. 어떠한 알고리즘의 로직이 '얼마나 오랜 시간'이 걸리는지를 나타내는 데 쓰이며, 보통 빅오 표기법으로 나타냅니다.

### 빅오 표기법
입력 범위 n을 기준으로 해서 로직이 몇 번 반복되는지 나타내는 것입니다. '가장 영향을 많이 끼치는' 항의 상수 인자를 빼고 나머지 항을 없앤 표기입니다.   
입력 크기가 커질수록 연산량이 가장 많이 커지는 항은 n의 제곱항이고, 다른 것은 그에 비해 미미하기 때문에 이것만 신경쓰면 된다는 이론입니다.

### 시간 복잡도의 존재 이유
효율적인 코드로 개선하는 데 쓰이는 척도가 됩니다.

### 시간 복잡도와 속도 비교
<img src="/Chapter05/한윤호/img/big_o.png" title="시간 복잡도 속도 비교" alt="시간 복잡도 속도 비교"></img><br/>

## 공간 복잡도
프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양을 말합니다.

# 선형 자료 구조
요소가 일렬로 나열되어 있는 자료 구조를 말합니다.

## 연결 리스트
데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화시킨 자료 구조입니다.   
삽입과 삭제가 O(1)이 걸리며 탐색에는 O(n)이 걸립니다.

## 배열
같은 타입의 변수들로 이루어져 있고, 크기가 정해져 있으며, 인접한 메모리 위치에 있는 데이터를 모아놓은 집합입니다. 중복을 허용하고 순서가 있습니다.   
탐색에 O(1)이 되어 랜덤 접근(random access)이 가능합니다. 삽입과 삭제에는 O(n)이 걸립니다.

### 랜덤 접근과 순차적 접근
직접 접근이라고 하는 랜덤 접근은, 동일한 시간에 배열과 같은 순차적인 데이터가 있을 때 임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능입니다.   
이는 데이터를 저장된 순서대로 검색해야 하는 순차적 접근과는 반대입니다.

### 배열과 연결 리스트 비교
배열은 상자를 순서대로 나열한 데이터 구조이며, 몇 번째 상자인지만 알면 해당 상자의 요소를 끄집어낼 수 있습니다.   
연결 리스트는 상자를 선으로 연결한 형태의 데이터 구조이며, 상자 안의 요소를 알기 위해서는 하나씩 상자 내부를 확인해봐야 한다는 점이 다릅니다.

## 벡터(vector)
동적으로 요소를 할당할 수 있는 동적 배열입니다. 중복을 허용하고 순서가 있고 랜덤 접근이 가능합니다.   
탐색과 맨 뒤의 요소를 삭제하거나 삽입하는 데 O(1)이 걸리며, 맨 뒤나 맨 앞이 아닌 요소를 삭제하고 삽입하는 데 O(n)의 시간이 걸립니다.

## 스택
가장 마지막으로 들어간 데이터가 가장 첫 번재로 나오는 성질(LIFO, Last In First Out)을 가진 자료 구조입니다.   
삽입 및 삭제에 O(1), 탐색에 O(n)이 걸립니다.

## 큐(queue)
먼저 집어넣은 데이터가 먼저 나오는 성질(FIFO, First In First Out)을 지닌 자료 구조입니다.   
삽입 및 삭제에 O(1), 탐색에 O(n)이 걸립니다.   
CPU 작업을 기다리는 ㅡ프로세스, 스레드 행렬 또는 네트워크 접속을 기다리는 행렬, 너비 우선 탐색, 캐시 등에 사용됩니다.

# 비선형 자료 구조
일렬로 나열하지 않고 자료 순서나 관계가 복잡한 구조를 말합니다.   
일반적으로 트리나 그래프를 말합니다.

## 그래프
정점과 간선으로 이루어진 자료 구조를 말합니다.

### 점선과 간선
어떠한 곳에서 어떠한 곳으로 무언가를 통해 간다고 했을 때, '어떠한 곳'은 정점(vertex)이 되고 '무언가'는 간선(edge)이 됩니다.   
정점으로 나가는 간선을 해당 정점의 outdegree라고 하며, 들어오는 간선을 해당 정점의 indegree라고 합니다. 또한, 정점은 약자로 V 또는 U라고 하며, 보통 어떤 정점으로부터 시작해서 어떤 정점까지 간다를 "U에서부터 V로 간다"라고 표현합니다.   
지금까지 설명한 정점과 간선으로 이루어진 집합을 '그래프(graph)'라고 합니다.

#### 가중치
간선과 정점 사이에 드는 비용을 뜻합니다.

## 트리
그래프 중 하나로, 트리 구조로 배열된 일종의 계층적 데이터의 집합입니다.

### 트리의 구성
루트 노드, 내부 노드, 리프 노드 등으로 구성됩니다.

### 루트 노드
가장 위에 있는 노드를 뜻합니다.

### 내부 노드
루트 노드와 리프 노드 사이에 있는 노드를 뜻합니다.

### 리프 노드
자식 노드가 없는 노드를 뜻합니다.

### 트리의 높이와 레벨
- 깊이 : 각 노드마다 다르며, 루트 노드부터 특정 노드까지 최단 거리로 갔을 때의 거리를 말합니다.
- 높이 : 루트 노드부터 리프 노드까지 거리 중 가장 긴 거리를 의미합니다.
- 레벨 : 주어지는 문제마다 다르지만, 보통 깊이와 같은 의미를 가집니다.
- 서브트리 : 트리 내의 하위 집합을 서브트리라고 합니다. 트리 내에 있는 부분집합이라고 보면 됩니다.

### 이진 트리
자식의 노드 수가 두 개 이하인 트리를 의미하며, 다음과 같이 분류합니다.
- 정이진 트리(full binary tree) : 자식 노드가 0 또는 두 개인 이진 트리를 의미합니다.
- 완전 이진 트리(complete binary tree) : 왼쪽에서부터 채워져 있는 이진 트리를 의미합니다. 마지막 레벨을 제외하고는 모든 레벨이 완전히 채워져 있으며, 마지막 레벨의 경우 왼쪽부터 채워져 있습니다.
- 변질 이진 트리(degenerate binary tree) : 자식 노드가 하나밖에 없는 이진 트리를 의미합니다.
- 포화 이진 트리(perfect binary tree) : 모든 노드가 꽉 차 있는 이진 트리를 의미합니다.
- 균형 이진 트리(balanced binary tree) : 왼쪽과 오른쪽 노드의 높이 차이가 1 이하인 이진 트리를 의미합니다.

### 이진 탐색 트리(BST)
노드의 오른쪽 하위 트리에는 '노드 값보다 큰 값'이 있는 노드만 포함되고, 왼쪽 하위 트리에는 '노드 값보다 작은 값'이 들어 있는 트리를 말합니다. 이렇게 두면 '검색'을 하기에 용이합니다.   
보통 요소를 찾을 때 이진 탐색 트리의 경우 O(log n)이 걸립니다. 하지만 최악의 경우에는 O(n)이 걸리는데, 이유는 삽입 순서에 따라 선형적일 수 있기 때문입니다.

### AVL(Adelson-Velsky and Landis) 트리
앞서 설명한 최악의 경우 선형적인 트리가 되는 것을 방지하고 스스로 균형을 잡는 이진 탐색 트리입니다.   
탐색, 삽입, 삭제 모두 시간 복잡도가 O(log n)이며, 삽입 삭제할 때마다 균형이 안 맞는 것을 맞추기 위해 트리 일부를 왼쪽 혹은 오른쪽으로 회전시키며 균형을 잡습니다.

### 레드 블랙 트리
균형 이진 탐색 트리로 탐색, 삽입, 삭제 모두 시간 복잡도가 O(log n)입니다.   
각 노드는 빨간색 또는 검은색의 색상을 나타내는 추가 비트를 저장하며, 삽입 및 삭제 중에 트리가 균형을 유지하도록 하는 데 사용됩니다.   
"모든 리프 노드와 루트 노드는 블랙이고, 어떤 노드가 레드이면 그 노드의 자식은 반드시 블랙이다" 등의 규칙을 기반으로 균형을 잡는 트리입니다.

## 힙
완전 이진 트리 기반의 자료 구조이며, 최소힙과 최대힙 두 가지가 있고, 해당 힙에 따라 특정한 특징을 지닌 트리를 말합니다.
- 최대힙 : 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 가장 커야 합니다. 또한, 각 노드의 자식 노드와의 관계도 이와 같은 특징이 재귀적으로 이루어져야 합니다.
- 최소힙 : 루트 노드에 있는 키는 모든 자식에 있는 키 중에서 최솟값이어야 합니다. 또한, 각 노드의 자식 노드와의 관계도 이와 같은 특징이 재귀적으로 이루어져야 합니다.
힙에는 어떠한 값이 들어와도 특정 힙의 규칙을 지키게 만들어져 있습니다.

### 최대힙의 삽입
힙에는 새로운 요소가 들어오면, 일단 새로운 노드를 힙의 마지막 노드에 이어서 삽입합니다. 이 새로운 노드를 부모 노드들과의 크기를 비교하며 교환해서 힙의 성질을 만족시킵니다.

### 최대힙의 삭제
최댓값은 루트 노드이므로 루트 노드가 삭제되고, 그 이후 마지막 노드와 루트 노드를 스왑하여 또다시 스왑 등의 가정을 거쳐 재구성됩니다.

## 우선순위 큐
우선순위 대기열이라고도 하며, 대기열에서 우선순위가 높은 요소가 우선순위가 낮은 요소보다 먼저 제공되는 자료 구조입니다. 우선순위 큐는 힙을 기반으로 구현됩니다.

## 맵
특정 순서에 따라 키와 매핑된 값의 조합으로 형성된 자료 구조입니다. 레드 블랙 트리 자료 구조를 기반으로 형성되고, 삽입하면 자동으로 정렬됩니다.   
맵은 해시 테이블을 구현할 때 사용합니다.

## 셋
특정 순서에 따라 고유한 요소를 저장하는 컨테이너이며, 중복되는 요소는 없고 오로지 희소한(unique) 값만 저장하는 자료 구조입니다.

## 해시 테이블
무한에 가까운 데이터들을 유한한 개수의 해시 값으로 매핑한 테이블입니다.   
삽입, 삭제, 탐색 시 평균적으로 O(1)의 시간 복잡도를 가집니다.

