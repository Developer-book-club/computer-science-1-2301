# 05. 자료 
**자료 구조(data structure)** 는 효율적으로 데이터를 관리하고 수정, 삭제, 탐색, 저장할 수 있는 데이터 집합을 말한다. 즉 자료구조는 대량의 데이터를 효율적으로 관리할 수 있는 데이터 구조를 말한다. 


![](https://velog.velcdn.com/images/wlsgml4563/post/3527c477-0e67-4424-88dc-29ec409a5335/image.png)


### C++ 기본
`C++` 는 STL을 기반으로 전반적인 자료 구조를 가장 잘 설명할 수 있는 언어이며, 이를 기반으로 자료 구조에 대한 참고 코드를 제공한다.   

▼ex) 입력받은 문자열 출력 프로그램
```
#include <bits/stdc++.h> // --- (1) 헤더 파일 STL 라이브러리 import / bits/stdc++.h는 모든 라이브러러리가 포함된 헤더더
using namespace std;     // --- (2) namespace: 같은 클래스 이름 구별, 모듈화에 쓰이는 이름을 말한다.
string a;                // --- (3) 문자열 선언: <타입><변수명> ex) String a = "만두"  => a: ivalue(다시 사용 가능 변수) / 만두: rvalue(한 번만 사용 )
int main()
{
    cin >> a;            // --- (4)  입력 함수: cin , scanf
    cout << a << "\n";   // --- (5)  출력 함수: cout, printf
    return 0;            // --- (6)  프로세스 마무리리
} 
```
# 5.1 복잡도
## 시간 복잡도

알고리름의 로직을 코드로 구현할 때, 시간 복잡도를 고려한다는 것은 '입력값의 변화에 따라 연산을 실행할 때,연산 횟수에 비해 시간이 얼마나 걸리는지'를 나타내는데 쓰인다.   
- 효율적인 알고리즘을 구현한다는 것 = 입력값이 커짐에 따라 증가하는 시간의 비율을 최소화한 알고리즘을 구성했다.    
- 보통 시간 복잡도는 **빅오 표기접**으로 나타낸다. 

> **빅오 표기법**  
> - 입력 범위 `n` 을 기준으로 해서 로직이 몇 번 반복되는지 나타내는 것  
> - 시간 복잡도는 최악, 최선, 중간의 경우에 대하여 나타낸다.  
> - 빅오 표기법은 최악의 경우로 알고리즘의 성능을 파악한다.  

### 시간 복잡도의 속도 비교  
![](https://velog.velcdn.com/images/wlsgml4563/post/7d520595-39d6-4ae6-b159-4e485281285b/image.png)   

|종류|설명|
|------|---|
|O(1) 일정한 복잡도|입력값이 증가하더라도 시간이 늘어나지 않는다.|
|O(n) 선형 복잡도|입력값이 증가함에 따라 시간 또한 같은 비율로 증가한다.|
|O(log n) 로그 복잡도|입력값이 증가함에 따라 시간은 절반으로 줄어들게 된다. ex) up&down 게임|
|O(n^2) 2차 복잡도|입력값이 증가함에 따라 시간이 n의 제곱수의 비율로 증가하는 것을 의미  


### 자료구조에서의 시간 복잡도
![](https://velog.velcdn.com/images/wlsgml4563/post/ce22fc28-2f96-4176-8876-d19a186b2eb3/image.png)  
출처: https://www.bigocheatsheet.com/



## 공간 복잡도
공간 복잡도는 프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양을 말한다.  
- 예전에 비해 컴퓨터 성능의 발달로 인해 메모리 공간이 넘쳐나다 보니 중요도는 떨어졌다.   


# 5.2 선형 자료 구조   
#### 자료를 구성하는 원소들을 순차적으로 나열시킨 형태를 의미한다. 

## 연결리스트
연결리스트는 자료들을 임의의 기억공간에 기억시키되 자료 항목의 순서에 따라 노드의 포인터 부분을 이용하여 서로 연결시킨 자료구조이다.     
✔️가장 첫 번째 노드를 `헤더` 라고 부르고, 가장 마지막 노드를 `테일` 이라고 한다.    
- 종류      
	
    - 싱글 연결 리스트: 노드 당 한 개의 포인터가 있고 포인터는 다음 노드의 위치를 가르킨다. 테일 포인터를 갖지 않는다.(null)
    - 이중 연결 리스트: 노드 당 두 개의 포인터가 이전 노드과 다음 노드를 가르킨다.    
    - 원형 이중 연결 리스트: 이중 연결 리스트에 테일의 포인터가 헤더를 가르킨다.  
    
- 장점: 연결 리스트 중 중간 노드의 연결이 끊어지면 그 다음 노드를 찾기 힘들지만, 노드의 연결이 끊어지지만 않는다면 중간에 `삽입` ,`삭제`가 빠르고 용이하다. 
- 단점: 연결을 위한 포인터 부분이 필요하기 때문에 순차 리스트, 배열에 비해 기억공간 이용 효율이 좋지는 않다.(접근 속도가 느리다.)  
 
 
## 배열
배열(`정적 배열` 기반)은 같은 타입의 변수들로 이루어져 있고, 크기가 정해져 있으며, 인접한 메모리 위치에 데이터를 모아놓은 집합이다. 인덱스를  가지고 있으며, 순차적으로 데이터가 삽입, 삭제될 수 있는 형태의 자료구조이다.  
- 장점: 인덱스를 사용하기 때문에 `검색` 이 빠르다.    
- 단점: 중간에 삽입, 삭제가 어렵다.      
> **✔️연결리스트와 배열 비교**
> - 데이터 탐색: 배열이 더 빠름. (`랜덤 접근` 가능)
> - 데이터 추가 및 삭제: 연결리스트가 더 빠름.
>`랜덤 접근` : 순차적인 데이터가 있을 때 임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능  

## 벡터 ⁉️
벡터는 배열을 이용해 만든 자료구조로, 동적으로 요소를 할당할 수 있는 `동적 배열` 이다.    
➕C++ 프로그래밍 언어에서 벡터(std::vector)는 유동적으로 크기 조절이 가능한 배열 자료 구조를 구현한 것입니다. 


## 스택  
스택은 리스트의 한 쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어진다.  가장 마지막으로 들어간 데이터가 가장 첫 번째로 나오는 성질 **(LIFO, Last In First Out)** 을 가진 자료 구조이다.  
- 자료 입력 명령어인 PUSH  
- 자료 출력 명령어인 POP 이 있다.  
## 큐  
큐는 리스트의 한 쪽에서는 삽입 작업이 이루어지고 다른 한 쪽에서는 삭제 작업이 이루어진다. 가장 먼저 삽입된 자료가 가장 먼저 출력되는 성질(FIFO, First In First Out)을 가진 자료구조이다.
✔️ 삭제 작업이 이루어지는 `Front 포인터`,  삽입 작업이 이루어지는 `Rear 포인터`        

# 5.3 비선형 자료 구조   
순차적으로 나열되지 않고 자료 순서나 관계가 복잡한 구조를 말한다.  

## 그래프
그래프는 `정점`과 `간선` 으로 이루어진 자료 구조를 말한다. 연결되어 있는 객체 간의 <u>관계를 표현할 수 있는 자료구</u> 이다.   
- 정점(Vertex): 데이터의 위치를 나타내는 개념  
- 간선(Edge): 노드를 연결하는 선 
💡간선'은 무엇과 무엇을 연결하는지에 대한 중요한 관계를 나타내므로 **간선을 저장하는 것**이 **그래프를 저장하는 것**이 된다.
>   ![](https://velog.velcdn.com/images/wlsgml4563/post/ceacf55b-9fe2-4a11-a5d0-7cbb31d64448/image.png)
> 정점 : {1, 2, 3, 4, 5, 6}  
> 간선 : {(1, 2), (1, 5),  (2, 5), (2, 3), (3, 4), (2, 4), (4, 5), (4, 6)}

- 진입 차수 (indegree): 정점으로 들어오는 간선의 수 
- 진출 차수(outdegree): 정점으로 나가는 간선의 수  
> ![](https://velog.velcdn.com/images/wlsgml4563/post/cfb305d9-82de-42f2-ae2e-ad3e64a85c47/image.png)


## 트리   
트리는 그래프의 일종으로 `정점` 과 `간선`으로 이루어져 있고, 트리 구조로 배열된 일종의 계층적 데이터의 집합이다.     
- **트리의 구조**    
	
    - 최상위 노드를 `루트 노드`    
    - 루트노드와 리프 노드 사이의 노드들을 `내부 노드`   
    - 최하위 노드들을 `리프 노드`
    
- **트리의 높이와 레벨**  
	
    - 깊이: 루트 노드부터 특정 노드까지 최단 거리로 갔을 때 간선의 수  
    - 높이: 루트 노드부터 리프 노드까지 중 가장 긴 간선의 수  
    - 레벨: 보통 깊이와 같은 의미를 지닌다.  
    - 서브 트리: 트리 내의 하위 집합  
    
- **트리의 특징 **  
	- 어떤 노드보다 위에 있으면 `부모` , 아래 있으면 `자식` 노드가 된다.  
    - 루트노드를 제외한 모든 노드는 단 하나의 부모노드를 가진다.   
    - V(정점) - 1 = E (간선 수)  
    - 저장된 데이터를 효과적으로 탐색하기 위해 사용된다.   
    
### 이진 트리 (Binary Tree)  
이진트리는 자식의 노드 수가 두 개 이하인 트리를 의미한다.   
- 정이진 트리(full binary tree):  자식 노드가 `0` 또는 `두 개` 인 이진트리  - 완전 이진 트리(complete binary tree): `왼쪽` 에서부터 채워져 있는 이진 트리  
- 변질 이진 트리(degenerate binary tree): 자식 노드가 하나밖에 없는 이진트리  
- 포화 이진 트리(perfect binary tree): 리프노드를 제외한 모든 노드가 두 개인 이진트리
- 균형 이진 트리(balanced binary tree): 왼쪽과 오른쪽 `노드의 높이 차이` 가 1 이하인 이진트리 => `map` , `set` 을 구성하는 `레드 블랙 트리` 가 대표적이다.  
### 이진 탐색 트리 (Binary Search Tree)  
자식 노드의 왼쪽 노드 `left node` => 부모노드보다 작은 값이 저장  
자식 노드의 오른쪽 노드 `right node`  => 부모노드보다 크거나 같은 값이 저장된다.   

### AVL 트리 (Adelson Velsky and Landis tree)  
이진 탐색 트리는 최악의 경우 삽입 순서에 따라 선형적일 수 있는데, 이를 방지하고 스스로 균형을 잡는 것이 AVL 트리이다.    
💡두 자식 서브트리의 높이는 항상 최대 1만큼 차이 난다.  

### 레드 블랙 트리  
레드 블랙 트리는 균형 이진 탐색 트리 로,   
각 노드는 빨간색 또는 검은색의 색상을 나타내는 추가 비트를 저장하며, <u>삽입 및 삭제 중에 트리가 균형을 유지하도록 하는 데 사용된다.</u>   
  
💡다음 5가지 조건을 만족하는 이진탐색 트리를 레드 블랙 트리라고 부른다
- 각 노드의 색은 `red` 또는 `black`   
- 루트 노드는 `black`  
- 모든 리프 노드는 `black` 이다.  
- `red` 노드의 자식 노드들은 전부 `black` 이다.   
- 루트노드에서 시작해서 리프노드에 이르는 모든 경로에는 동일한 개수의 `black` 노드가 존재한다.  
  


## 힙  
완전 이진 트리 기반의 자료 구조이며, 최대값, 최솟값을 찾아내는 연산을 쉽게 하기 위해 고안된 자료형이다.   
`최소힙` / `최대힙` 중 해당 힙에 따라 특정한 특징을 지킨 트리를 말한다.  
- 최소힙: 루트 노드의 키 값이 < 자식 노드보다 작아야 한다.
- 최대힙: 루트 노드의 키 값이 > 자식 노드보다 커야 한다.

💡 각 노드의 자식 노드와의 관계도 재귀적으로 이루어져야 함  
## 우선순위 큐   
먼저 들어오는 데이터가 아니라, 우선순위가 높은 데이터가 먼저 나가는 형태의 자료구조이다.   
- 우선순위 큐는 일반적으로 힙(Heap)을 이용하여 구현한다.    
![](https://velog.velcdn.com/images/wlsgml4563/post/d52a00b3-05cb-4aad-832a-a094da872368/image.png)



## 맵  
특정 순서에 따라 키(Key)와 매핑된 값(Value)의 조합으로 형성된 자료 구조입니다. 키를 통해 값에 접근을 할 수 있도록 만들어졌기 때문에 대응하는 값을 찾기 위해서 중복을 허용하지 않는다.     

- **HashMap**
key와 value의 쌍으로 구성되나 자료구조 안에 묶인 쌍들에 대한 순서는 보장할 수 없다. 키와 값이 구성되는 위치를 결정 하거나 알 수 없다.   
- **TreeMap**    
key 값을 이용해 순서대로 정렬하여 데이터를 저장하는 자료구조이다. key값의 정렬을 통한 탐색 등을 하기에 용이하다.  
- **LinkedHashMap**
데이터를 입력한 순서대로 쌓아지며 데이터를 저장하는 자료구조
배열, 리스트처럼 인덱싱 접근을 하기에 용이하다. 

## 셋    
셋은 특정 데이터들을 모아두는 장소(집합)이며, 특정 순서대로 데이터를 저장하지 않아 순서가 상관없고 데이터의 중복을 허용하지 않을 떄 사용하는 자료구조이다.  


## 해시 테이블

해시테이블이란 각각의 Key 값에 해시 함수를 적용하여 배열의 고유한 Index를 생성하고, 이 Index 를 활용해 Key와 Value를 저장하거나 검색하는 자료구조를 말한다.

