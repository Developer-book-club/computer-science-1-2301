# 3.2 메모리



## 3.2.1 메모리 계층

### 구성

- **레지스터** : CPU 안에 있는 메모리
- **캐시** : L1,L2 캐시 / 휘발성, 속도 빠름, 기억 용량이 적음
- **주기억장치** : RAM / 휘발성, 속도 보통, 기억 용량 보통
    - 하드디스크로부터 일정량의 데이터를 복사해서 임시 저장하고 이를 필요시마다 CPU에 전달
- 보조기억장치 : HDD,SSD / 비휘발성, 속도 낮음, 기억용량 많음

> 계층 위로 올라갈수록 가격은 비싸지고 용량은 작아진다.
> 

> 로딩중 → 하드디스크/인터넷에서 데이터를 읽어 RAM으로 전송하는 과정
> 

### 캐시

<aside>
💡 데이터를 미리 복사해놓는 임시 저장소이자 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리

</aside>

- 캐싱 계층 : 메모리와 CPU 사이의 속도 차이가 너무 크기 때문에 그 중간에 레지스터 계층을 둬서 속도 해결하기 위한 계층
    - EX) 캐시 메모리와 보조기억장치 사이에 있는 주기억장치

### 지역성의 원리

- 캐시에 어떤 데이터를 먼저 넣어놓는 것이 효율적인가?
    - 시간 지역성 / 공간 지역성을 고려
- 시간지역성 : 최근 사용한 데이터에 다시 접근하려는 특성
- 공간지역성 : 최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하는 특성

### 캐시히트와 캐시미스

- 캐시히트 : 캐시에서 원하는 데이터를 찾은 경우
- 캐시미스 : 데이터가 캐시에 없을 때 주메모리에 가서 데이터를 찾아오는 경우
- 캐시매핑 : 캐시가 히트되기 위해 매핑하는 방법
    - 직접매핑 : 순서에 따라 메모리 매핑
        - 처리가 빠르지만 충돌 발생이 잦다.
    - 연관 매핑 : 순서를 일치시키지 않고 관련 있는 캐시와 메모리 매핑
        - 충돌이 적으나 모든 블록을 탐색해야 하므로 속도가 느리다.
    - 집합연관 매핑
        - 순서는 일치하지만 집합을 두어 저장하며 블록화하여 검색의 효율성을 높임.

### 웹브라우저의 캐시

- 쿠키
    - 만료기한이 있는 키-값 저장소
    - 다른 도메인에서 요청했을 때 자동으로 전송된다
    - 서버에서 만료기한을 정한다
    
- 로컬 스토리지
    - 만료기한이 없는 키-값 저장소
    - 웹브라우저를 닫아도 유지되고 도메인 단위로 저장,생성
    - HTML5를 지원하지 않는 웹브라우저는 사용할 수 없음
    - 클라이언트에서만 수정 가능
    
- 세션 스토리지
    - 만료기한이 없는 키-값 저장소
    - 탭 단위로 세션 스토리지를 생성하며, 탭을 닫을 때 데이터가 삭제
    - HTML5를 지원하지 않는 웹브라우저에서 사용 불가능
    - 클라이언트에서만 수정 가능

### 데이터베이스의 캐싱 계층

- 메인 데이터베이스 위의 **레디스(redis) 데이터베이스 계층**을 캐싱 계층으로 두어 성능을 향상시킬 수 있다.

## 3.2.2 메모리 관리

<aside>
💡 컴퓨터 내의 한정된 메모리를 극한으로 활용

</aside>

### 가상메모리

<aside>
💡 메모리 관리 기법의 하나로 컴퓨터가 실제로 이용 가능한 **메모리 자원을 추상화**하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것

</aside>

- 가상 주소 : 가상적으로 주어진 주소
- 실제 주소 : 실제 메모리상에 있는 주소
- **MMU** : 가상 주소와 실제 주소를 변환
- **페이지테이블** : 가상 주소와 실제 주소가 매핑되어 있고 프로세스의 주소 정보가 들어 있는 테이블 → 속도 향상을 위해 **TLB**를 사용
    
    > TLB : 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시 CPU가 페이지 테이블까지 매번 가지 않도록 해 속도를 향상시킨다.
    > 

- **스와핑**
    
    > 가상 메모리에는 존재하지만 실제 메모리 RAM에 현재 없는 데이터나 코드에 접근할 경우 페이지 폴트가 발생
    > 
    - 메모리에서 당장 사용하지 않는 영역을 하드디스크로 옮기고 하드디스크의 일부분을 메모리처럼 불러와 쓴다.
    - 페이지 폴트 처리과정
        1. CPU는 물리 메모리를 확인하여 해당 페이지가 없으면 트랩을 발생해서 운영체제에 알린다.
        2. 운영체제는 CPU의 동작을 잠시 멈춘다.
        3. 페이지 테이블을 확인하여 가상메모리에 페이지가 존재하는지 확인하고 없으면 프로세스를 중단하고 현재 물리 메모리에 비어 있는 프레임이 있는지 찾는다. / 물리메모리에도 없는 경우 스와핑 발동
        4. 비어 있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화한다.
        5. 중단되었던 CPU를 다시 시작한다. 
    
    > **페이지** : 가상 메모리를 사용하는 최소 크기 단위
    > 
    
    > **프레임** : 실제 메모리를 사용하는 최소 크기 단위
    > 

### 스레싱

<aside>
💡 메모리의 페이지 폴트율이 높다는 것을 의미, → 컴퓨터의 성능 저하를 초래

</aside>

- 메모리에 너무 많은 프로세스가 동시에 올라가는 경우 → 스와핑 많이 발생 → CPU 이용률 낮아짐 → 운영체제는 CPU가 한가하다고 생각해서 더 많은 프로세스를 올림 → 스레싱
- 해결방법
    1. 메모리를 늘린다.
    2. HDD를 SSD로 바꾼다. 
    3. **작업세트**
        - 프로세스의 과거 사용 이력인 지역성(Locality)를 통해 결정된 페이지 집합을 만들어서 미리 메모리에 로드한다.
        - 미리 메모리에 로드해서 탐색에 드는 비용을 줄일 수 있다.
    4. **PFF(Page Fault Frequency)**
        - 페이지 폴트 빈도를 조절하는 상한선과 하한선을 만든다.
        - 상한선에 도달한다면 프레임을 늘리고 하한선에 도달한다면 프레임을 줄인다.

### 메모리 할당

<aside>
💡 시작 메모리 위치 / 메모리의 할당 크기 기반 으로 메모리를 할당

</aside>

- **연속할당**
    - 메모리에 연속적으로 공간을 할당
    
    - **고정분할방식** :
        - 메모리를 미리 나누어 관리하는 방식
        - 융통성이 없고, 내부 단편화가 발생
        
        > 내부 단편화 : 메모리를 나눈 크기보다 프로그램이 작아서 남는 공간이 많이 발생하는 현상
        > 
    
    - **가변분할방식**:
        - 매 시점 프로그램의 크기에 맞춰 동적으로 메모리를 나누어 사용
        - 내부 단편화는 발생하지 않으나 외부 단편화가 발생
        
        | 최초적합 | 위쪽이나 아래쪽부터 시작해서 홀을 찾으면 바로 할당 |
        | --- | --- |
        | 최적적합 | 프로세스의 크기 이상인 공간 중 가장 작은 홀부터 할당 |
        | 최악적합 | 프로세스의 크기와 가장 많이 차이가 나는 홀에 할당  |
        
        > 외부 단편화 : 메모리를 나눈 크기보다 프로그램이 켜서 들어가지 못하는 공간이 많이 발생하는 현상
        > 

- 불연속할당
    - 메모리를 연속적으로 할당하지 않음 → 현대운영체제에서 사용
    - **페이징** : 메모리를 동일한 크기의 페이지로 나누고 프로그램마다 페이지 테이블을 두어 이를 통해 메모리에 프로그램을 할당
    
    - **페이징**
        - 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당
        - 홀의 크기가 균일하지 못한 문제가 없어진다.
        - 주소 변환이 복잡
        
    - **세그멘테이션**
        - 페이지 단위가 아닌 의미 단위인 세그먼트로 나누는 방식
        - 코드 / 데이터 / 함수 단위 등 여러 가지 단위를 기준으로 나눌 수 있다.
        - 공유와 보안 측면에서의 장점이 있다.
        - 홀 크기가 균일하지 못하다는 문제점
        
    - **페이지드 세그멘테이션**
        - 공유나 보안은 의미 단위의 세그먼트로 나누고, 물리적 메모리는 페이지로 나눔
        

### 페이지 교체 알고리즘

1. 오프라인 알고리즘
    - 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘
    - **FIFO** : 가장 먼저 온 페이지를 교체 영역에 먼저 놓는다.
    - **LRU** : 참조가 가장 오래된 페이지부터 바꾼다.
        - ‘오래된’ 것을 파악하기 위해 각 페이지마다 계수기, 스택을 두어야 한다.
        - 해시테이블과 이중연결리스트로 구현
    - **NUR** : LRU 에서 발전한 버전
        - 0 과 1을 가진 비트를 둔다.
        - 0 = 최근에 참조되지 않음
        - 1 = 최근에 참조됨
        - 시계방향으로 돌면서 0을 찾고 0을 찾는 순간 해당 프로세스를 교체하여 1로 바꾼다.
    - **LFU** : 참조 횟수가 가장 적은 페이지를 교체