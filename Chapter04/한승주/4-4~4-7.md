# ch4.4 ~ ch.4.7


## 4.4.1 관계형 데이터베이스

<aside>
💡 관계형 데이터베이스 : 행과 열을 가지는 표 형식의 데이터를 저장하는 형태의 데이터베이스

</aside>

- MySQL, PostgreSQL, 오라클, SQL Server, MSSQL 등
    - 표준 SQL은 지키지만, 각각의 제품에 특화시킨 SQL을 사용

### MYSQL

대부분의 운영체제와 호환되며 현재 가장 많이 사용하는 데이터베이스 

- C++, C 로 만들어짐
- MyISAM 인덱스 압축 기술, B-트리 기반의 인덱스, 스레드 기반의 메모리 할당 시스템, 빠른 조인, 64개 인덱스 등 지원
- 대용량 데이터베이스를 위해 설계되어 있고 롤백, 커밋, 이중 암호 지원 보안 등의 기능을 제공하며 많은 서비스에서 사용

### PostgreSQL

- `VACUUM` : 디스크 조각이 차지하는 영역을 회수하는 장치
- 최대 테이블의 크기는 32TB 이며 SQL 뿐만 아니라 JSON을 이용해서 데이터에 접근 가능
- 지정시간에 복구하는 기능, 로깅, 접근데어, 중첩된 트랜잭션, 백업 등 가능

## 4.4.2 NoSQL 데이터베이스

<aside>
💡 Not only SQL, SQL을 사용하지 않는 데이터베이스

</aside>

- MongoDB, redis 등

### MongoDB

JSON을 통해 데이터에 접근할 수 있고, Binary JSON 형태 (BSON)으로 데이터가 저장되며 와이어드타이거 엔진이 기본 스토리지 엔진으로 장착된 키-값 데이터 모델에서 확장된 도큐먼트 기반의 데이터베이스 

- 확장성이 뛰어나며 빅데이터를 저장할 때 성능이 좋다
- 고가용성, 샤딩, 레플리카셋 등 지원
- 스키마를 정해놓지 않고 데이터를 삽입할 수 있기 때문에 다양한 도메인의 데이터베이스를 기반으로 분석, 로깅 등을 구현할 수 있다.
- 도큐먼트를 생성할 때마다 다른 컬렉션에서 중복된 값을 지니기 힘든 `ObjectID` 가 생성됨
    - 기본키로, 유닉스 시간 기반의 타임스탬프, 랜덤 값, 가운터로 이루어짐

### redis

인메모리 데이터베이스이자 키-값 데이터 모델 기반의 데이터베이스 

- 기본적인 데이터 타입은 문자열(string)이며 최대 512mb 까지 저장
- set, hash 등 지원
- pub,sub 기능을 통해 채팅 시스템, 다른 데이터베이스 앞단에 두어 사용하는 캐싱 계층, 단순한 키-값이 필요한 세션 정보 관리, 정렬된 셋(sorted set) 자료 구조를 이용한 실시간 순위표 서비스 등에 사용

## 4.5.1 인덱스의 필요성

<aside>
💡 인덱스를 설정하면 테이블 안에 내가 찾고자 하는 데이터를 빠르게 찾을 수 있다.

</aside>

## 4.5.2 B-트리

인덱스는 보통 B-트리라는 자료구조로 구성되어 잇다.

- 루트노드
- 리프노드
- 브랜치노드

## 4.5.3 인덱스 만드는 방법

### MySQL

- **클러스터형 인덱스**
    - 테이블당 하나 설정 가능
    - `primary key` 옵션으로 기본키 만들기 ]
    - 기본키로 만들지 않고 `unique not null` 옵션 붙이기
- **세컨더리 인덱스**
    - `create index …` 명령으로 생성
    - 보조 인덱스로, 여러개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성하는 인덱스
    - 다양한 필드(age, name, email 등)를 기반으로 쿼리를 보낼 때 사용
    - 하나의 인덱스만 생성할 것이라면 세컨더리 인덱스 보다는 클러스터형 인덱스를 만드는 것이 좋다.
    

### MongoDB

- 도큐먼트를 만들면 자동으로 `ObjectID` 가 형성되며, 해당 키가 기본키로 설정됨
- 세컨더리키를 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 복합인덱스 설정 가능

## 4.5.4 인덱스 최적화 기법

> 책에서는 MongoDB를 바탕으로 인덱스 최적화 기법을 설명
> 

### 1. 인덱스는 비용이다

- 인덱스를 쓰면 두번 탐색된다
    - 인덱스리스트 → 컬렉션 순으로 탐색하여 읽기 비용 증가
- 컬렉션이 수정되었을 때 인덱스도 수정되어야 한다.
    - B-트리의 높이 조절 비용
    - 데이터를 효율적으로 조회할 수 있도록 분산시키는 비용
- 컬렉션에서 가져와야 하는 양이 **많을 수록 인덱스를 사용하는 것은 비효율적**

### 2. 항상 테스팅하라

- 서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다르기 때문에 테스팅 하는 것이 중요
- `explain()` 함수를 통해 인덱스를 만들고 쿼리를 보낸 이후에 테스티을 하며 걸리는 시간을 최소화

### 3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다.

- 인덱스를 생성할 때 순서가 있고, 생성 순서에 따라 인덱스 성능이 달라진다.
    - **정렬 → 다중값 → 카디널리티** 순으로 생성해야함

1. `==`, `equal` 쿼리가 있다면 가장 먼저 인덱스로 설정
2. 정렬에 쓰는 필드라면 다음 인덱스로 설정
3. 다중 값을 출력해야 하는 필드 ⇒ `>` , `<` 등은 나중에 인덱스 설정
4. 카디널리티 - 유니크한 값의 정도
    1. 카디널리티가 **높은** 순서를 기반으로 인덱스를 설정
    2. ex) `age`와 `email` 중에서는 email이 카디널리티가 높다. 
    3. 흔하지 않은 값을 인덱스로 설정해야 중복으로 찾을 가능성이 낮으므로 ? 

### 조인

<aside>
💡 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것

</aside>

- MySQL : `JOIN`
- MongoBD : `lookup`
    - 관계형 데이터베이스보다 성능이 떨어지므로 되도록 사용하지 말아야 함
    - 여러 테이블을 조인하는 작업이 많을 경우 MongoDB보다는 관계형 데이터베이스를 
    써야 한다.

## 4.6.1 내부 조인

<aside>
💡 두 테이블 간의 교집합

</aside>

```sql
Select * FROM TableA A
INNER JOIN TABLEB B ON
A.key = B.key
```

## 4.6.2 왼쪽 조인

<aside>
💡 테이블 B의 일치하는 부분의 레코드와 함께 테이블 A를 기준으로 완전한 레코드 집합을 생성

</aside>

- 테이블 B에 일치하는 항목이 없으면 해당 값은 null 값이 된다.

```sql
SELECT * FROM TableA A
LEFT JOIN TableB B ON
A.key = B.key
```

## 4.6.3 오른쪽 조인

<aside>
💡 테이블 A에서 일치하는 부분의 레코드와 함께 테이블 B를 기준으로 완전한 레코드 집합을 생성

</aside>

- 테이블 A에 일치하는 항목이 없으면 해당 값은 null 이 된다.

```sql
Select * FROM TableA A
RIGHT JOIN TableB B ON
A.key = B.key
```

## 4.6.4 합집합 조인

<aside>
💡 양쪽 테이블에서 일치하는 레코드와 함께 테이블A와 테이블B의 모든 레코드 집합을 생성

</aside>

- 일치하는 항목이 없으면 누락된 쪽에 null 값이 포함되어 출력

```sql
SELECT * FROM TableA A
FULL OUTER JOIN TableB B ON
A.key = B.key 
```

> 4.6의 조인의 종류는 아래의 원리를 기반으로 조인한다.
> 

## 4.7.1 중첩 루프 조인

<aside>
💡 중첩 for 문과 같은 원리로 조건에 맞는 조인을 하는 방법이다.

</aside>

- 랜덤 접근에 대한 비용이 많이 증가하므로 대용량의 테이블에서는 사용하지 않는다.
- EX) T1, T2 테이블을 조인
    - 행을 하나씩 읽어 조건에 맞는 레코드를 찾아 결과값을 반환한다.
- 블록 중첩 루프 조인(BNL, Block Nested Loop)
    - 조인할 테이블을 작은 블록으로 나눠서 블록 하나씩 조인
    

## 4.7.2 정렬 병합 조인

<aside>
💡 각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행

</aside>

- 조인할 때 쓸 적절한 인덱스가 없음
- **대용량의 테이블**들을 조인하고 조인 조건으로 `<`.`>` 등 범위 비교 연산자가 있을 때 사용

## 4.7.3 해시 조인

<aside>
💡 해시 테이블을 기반으로 조인하는 방법

</aside>

- 하나의 테이블이 메모리에 온전히 들어간다면 보통 중첩 루프 조인보다 더 효율적
- MYSQL 의 해시 조인 단계
    1. 빌드 단계
        - 입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계
        - 조인하는 테이블 중 바이트가 더 작은 테이블을 기반으로 해서 테이블 빌드
        - 조인에 사용되는 필드가 해시 테이블의 키로 사용됨
        
    2. 프로브 단계
        - 프로브 단계 동안 레코드 읽기를 시작하며, 각 레코드에서 테이블 키에 일치하는 레코드를 찾아서 결과값으로 반환
        - 각 테이블을 한번씩만 읽게 된다.
            - 두 개의 테이블을 읽는 중첩 루프보다 일반적으로 성능이 더 좋다.