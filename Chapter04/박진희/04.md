
# 4 데이터 베이스

# 4.1 데이터베이스의 기본 

#### 데이터 베이스 (DB, Data Base)
일정한 규칙 혹은 규약을 통해 구조화되어 저장되는 데이터 모음이다.  

#### DBMS (DataBase Management System)
데이버 베이스를 제어, 관리하는 통합 시스템으로 DBMS 마다 정의된 쿼리 언어를 통해 `create` / `select` / `insert` /`update`등을 수행할 수 있다.  
=> MySQL, MS SQL, Oracle 등. 

## 4.1.1. 엔터티(Entity)
정의: 사람 , 장소, 물건, 사건, 개념 등과 같이 독립적으로 존재하면서 고유하게 식별이 가능한 여러 개의 속성을 지닌 객체를 의미한다
- 실체, 객체라는 의미로 실무적으로는 앤터티라고 부르며 업무에 필요하고 유용한 정보를 저장하고 관리하기 위한 집합적인  것으로 설명할 수 있다.     
ex)[회원]이라는 엔터티가 있다면 회원은 이름, 아이디, 주소 등의 **속성**을 가진다.  

- **강한 엔터티**  
독립적으로 존재 가능한 것       
=> ex)건물, 회원   
- **약한 엔터티**    
강한 엔터티의 존재 여부에 따라 종속적인 것    
=> ex)방, 주민등록번호    



## 4.1.2.릴레이션
정의: 데이테베이스에서 정보를 구분하여 저장하는 기본 단위로, <u>엔터티에 관한 데이터를 </u> 데이터 베이스는 **하나의 릴레이션** 에 담아서 관리한다.  
- 관계형 DB 에서는 **테이블** 이라고 한다.  
[레코드(행)] ->**[테이블]** -> DB  
- NoSQL DB  **컬렉션** 이라고 한다.    
[도큐먼트]  -> **[컬렉션]**->[DB]  


## 4.1.3. 속성 
정의: 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보이다.
- 서비스의 요구사항을 기반으로 관리해야 할 필요가 있는 필요가 있는(필수적인) 속성들만 엔터티의 속성이 된다.  


## 4.1.4. 도메인
도메인이란 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합을 말한다.  
=> 회원이라는 엔터티의 [성별] 이라는 속성이 가질 수 있는 값 {남, 여}는 **집합(도메인)**이 된다.

![](https://velog.velcdn.com/images/wlsgml4563/post/402514c3-c6c6-47ce-af75-1e39144bf14a/image.png)


## 4.1.5.필드와 레코드
### 필드
데이터 베이스에서 세로 단위의 컬럼(`열(column)`,`속성`)을 말한다.

### 필드 타입
>숫자 타입       

|타입  |용량|  
|:------|:---:|  
|TINYINT|1|    
|SMALLINT|2|  
|MEDIUMINT|3|  
|INT|4|  
|BIGINT|8|

>날짜 타입

|날짜 타입|지원 범위|용량|값|
|-----|---|---|---|
| DATE|1000-01-01~9999-12-31|3바이트|날짜 o , 시간 x|
| DATETIME|1000-01-01 00:00:00 ~ 9999-12-31 23:59:59|8바이트|날짜 O 시간 O|
|TIMESTAMP|1970-01-01 00:00:01 ~ 2038-01-19 03:14:07|4바이트 |날짜O 시간 O|

>문자 타입
  - CHAR 와 VARCHAR  
     CHAR(N): 선언한 길이 값으로 고정되어 저장된다.  (N: 0~255)  
     VARCHAR(N): 입력된 데이터에 따라 용량을 가변시켜 저장된다.(N:0~65535)
 - TEXT 와  BLOB   
   TEXT 는 큰 문자열 저장에 쓰인다.  
   BLOB 은 이미지, 동영상 등 큰 데이터 저장에 쓰인다.
 - ENUM 와 SET  
    문자열을 열거하는 타입으로 원하는 상태 값으로 DB 에 저장할 수 있다.
  

### 레코드
데이터 베이스에서 하나의 단위로 취급되는 자료의 집합을 말한다,
DB 테이블에서 가로 방향의 한 줄(`행(Row)`or `튜플`)로 나타난다.

## 4.1.6. 관계
DB 에는 여러 개의 테이블이 존재하며 이러한 테이블은 **서로의 관계** 가 정의되어 있다. 이러한 관계를 **관계 화살표 ** 로 나타낸다.
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FchcqPU%2FbtqWNcpFqo5%2FTs0an1KgZHLuZs5ntTasK1%2Fimg.png)
- 1:1 관계  
하나의 레코드가 다른 테이블의 레코드 한 개와 연결된 경우이다.  
- 1:N 관계  
하나의 레코드가 서로 다른 여러 개의 레코드와 연결된 경우이다.
- N: M 관계  
여러 개의 레코드가 다른 테이블의 여러 개의 레코드와 관계가 있는 경우이다.

## 4.1.7 키
테이블 간의 관계를 명확하게 하고 테이블 자체의 인덱스를 위해 설정된 장치로 `기본키`, `외래키`, `후보키`,`슈퍼키`, `대체키` 가 있다.  
### 후보키 (Candidate Key)  
- 릴레이션을 구성하는 속성(컬럼)들 중에서 행을 유일하게 식별할 수 있는 속성들의 부분 집합을 의미한다.   
- 릴레이션에 있는 모든 행에 대해서 유일성과 최소성을 만족시켜야 한다.

### 기본키 (Primary Key)
- 후보키 중에서 선택한 메인 키로 한 릴레이션에서 특정 행을 유일하게 구별할 수 있는 속성이다.  
- 유일성과 최소성을 만족하며 기본키로 정의된 속성은 동일한 값이 중복되어 저장될 수 없다.

### 외래키 (Foreign Key)
- 다른 테이블의 기본키를 그대로 참조하는 값으로 릴레이션 간에 참조 관계를 표현하는데 중요한 도구이다.  
- 외래키로 지정되면 참조 테이블의 기본키에 없는 값은 입력할 수 없다.
### 대체키(Alternate Key)   
- 후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키들을 말한다.
### 슈퍼키(Super Key)  
- 슈퍼키는 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키이다.    
- 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키이다.  
(최소성은 만족시키지 못한다.)
### 대체키(Alternate Key)
후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키들을 말한다.

# 4.2 ERD와 정규화 과정
## ERD 란?   
- 데이터베이스를 구축할 때 가장 기초적인 뼈대 역할을 하는 것  
- 릴레이션(테이블) 간의 관계들을 정의한 것
- 서비스 구축 시 가장 먼저 선행되어야 할 부분이다.  

> **💡ERD 의 중요성**  
> - ERD는 시스템의 요구 사항을 기반으로 작성되며 이 <u>ERD 를 기반으로 DB 를 구축한다.</u>  
> - DB 를 구축한 이후에도 디버깅 또는 비즈니스 프로세스 재설계가 필요한 경우에 설계도 역할을 담당하기도 한다.  
> - ERD는 관계형 구조로 표현할 수 있는 데이터를 구성하는데 유용하다.  
> - 미리 정의된 데이터 모델이 없는 비구조화 데이터, 즉 비정형 데이터는 ERD로 충분히 표현하기 어렵다.

## 정규화 과정  [🔎](https://hoyeonkim795.github.io/posts/normalization-course/)
#### 정의   
데이터의 **중복** 을 줄이고 **무결성**을 향상시키는 등 여러 목적을 달성하기 위해서 재디자인 하는 것을 말한다.
#### 목적   
릴레이션 간의 잘못된 종속 관계로 인해 **데이터 베이스 이상 현상**이 일어나서 이를 해결하거나, 저장 공간을 효율적으로 사용하기 위해 **릴레이션을 여러 개로 분리하는 과정이다.**  
#### 원칙
- 같은 의미를 표현하는 릴레이션이지만 더 좋은 구조로 만들어야 한다.  
- 자료의 중복성은 감소해야 한다.  
- 독립적인 관계는 별개의 릴레이션으로 표현해야 한다.  
- 각각의 릴레이션은 독립적인 표현이 가능해야 한다.    

✔️데이터베이스 이상 현상    
- 삽입 이상: 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야 하는 문제    
- 갱신 이상: 중복 행 중 일부만 변경하여 데이터가 불일치하게 되는 문제    
- 삭제 이상: 튜플을 삭제하면 꼭 필요한 데이터까지 같이 삭제되는 데이터 손실 문제    
 

> **제 1 정규형** 
- 릴레이션의 모든 도메인(속성의 값들)이 오직 원자 값(automic value) 만으로 구성되어야 한다.
- 모든 속성에 반복되는 그룹(집합)이 나타나지 않아야 한다.      

>**제 2 정규형**  
- 릴레이션이 제 1규형이며 **부분 함수의 종속성 **을 제거한 형태를 말한다.  
- 제 2 정규화는 테이블의 모든 컬럼이 완전 함수적 종속을 만족한다.

✔️부분 함수의 종속성 제거: 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것

>**제 3 정규형**  
- 비주요 속성(기본키가 아닌 속성)이 비주요 속성에 의해 종속되는 경우가 없는 릴레이션 형태를 말한다.  
- 기본키가 아닌 모든 속성이 **이행적 함수 종속**을 만족하지 않는 상태를 말한다.  

✔️이행적 함수 종속 : A -> B , B-> C 의 가 존재하면 논리적으로 A->C 가 추론되는데, 이때 C 가 A에 이행적으로 함수 종속되었다고 한다.    

>**보이스/코드 정규형**
- BCNF(Boyce and Codd Normal Form) 은 결정자가 후보키가 아닌 함수 종속 관계를 제거하여 모든 **결정자**가 후보키 집합에 속한 상태를 말한다.  

✔️결정자 : 함수 종속 관계에서 특정 종속자를 결정 짓는 요소로, X ->Y일 때,  <u>X 는 결정자 , Y는 종속자</u>  
![](https://velog.velcdn.com/images/wlsgml4563/post/a32838e9-ada8-4418-a1e5-11f3eef28d90/image.png)
강사 -> 수강명, 강사는 결정자

>**제 4 정규형 : 다치 종속 제거**  

>**제 5 정규형: 조인 종속성 제거**


# 4.3 트랜잭션과 무결성

## 4.3.1 트랜잭션
### 트랜잭션이란?
DB 에서 하나의 논리적 기능을 수행하기 위한 작업의 단위를 말하며 DB 에 접근하는 쿼리이다.<u>즉 여러 개의 쿼리들을 하나로 묶는 단위를 말한다.</u>   

### 트랜잭션의 특징

원자성, 일관성, 독립성, 지속성이 있으며 이를 한꺼번에 ACID 특징이라고 한다.

#### 원자성(atomicity)  
원자성은 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징이다.

>**커밋**  
> 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어로, <u>트랜잭션 단위로 수행되며</u> 변경된 내용이 모두 영구적으로 저장되는 것을 말한다.

>**롤백**  
> 에러나 여러 이슈로 트랜잭션 전으로 돌려야 할 때 사용하는 것으로,트랜잭션으로 처리한 하나의 묶음 과정을 <u>일어나기 전으로 돌리는 일</u>을 말한다.


#### 일관성(consistency)   
<u>허용된 방식</u> 으로만 데이터를 변경해야 하는 것을 의미한다. DB 에 저장된 모든 데이터는 여러 가지 조건, 규칙에 따라 유효함을 가져야 한다.

#### 격리성(isolation)  
트랜잭션 수행 시 서로 끼어들지 못하는 것을 말한다.  

> **격리 수준에 따라 발생하는 현상**
> - 팬텀 리드 Phantom read
> 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우를 말한다.  => 다른 행이 선택되어 출력될 수 있다.  
> - 반복 가능하지 않은 조회 Non repeatable read   
> 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데, 그 값이 다른 경우를 말한다. => 행 값이 달라질 수 있다.  
> - 더티 리드 Dirty read   
> 한 트랜잭션이 실행 중일 때 다른 트랜잭션에 의해 수정되었지만 아직 **'커밋되지 않은 행의 데이터'**를 읽을 수 있을 떄 발생한다.  

> **격리 수준**  
> - Serializable  
>   - 트랜잭션을 순차적으로 진행시키는 것을 말한다.   
>   - 매우 엄격한 수준으로 교착 상태가 일어날 확률이 많고 가장 성능이 떨어지는 격리 수준이다.
>  - Repeatable_Read  
>   - 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록 막아주지만 새로운 행을 추가하는 것은 막지 않는다.  
>   - 이후에 추가된 행이 발견될 수 있다.    
>  - Read Committed  
>   - 커밋 완료된 데이터에 대해서만 조회를 허용한다.
>   - 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수정할 수 있다.     
>   - 팬텀 리드와 반복 가능하지 않은 조회가 일어날 수 있다.
>  - Read Uncommitted    
>   - 트랜잭션에서 처리 중인 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다.  
>   - 팬텀 리드, 반복 가능하지 않은 조회, 더티 리드가 일어날 수 있다.


#### 지속성(durability)
성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것을 의미한다. 

## 4.3.2 무결성
### 무결성이란? 
데이터의 정확성, 일관성, 유효성을 유지하는 것을 말한다.  무결성이 유지되어야 DB에 저장된 데이터 값과 그 값에 해당하는 현실 세계의 실제 값이 일치하는지에 대한 신뢰가 생긴다.  

### 무결성 종류
#### 개체 무결성   
기본키로 선택된 필드는 빈 값을 허용하지 않는다.
####참조 무결성  
서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지해야 한다.
#### 고유 무결성  
특정 속성(열)에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유한 값을 가진다.  
#### NULL 무결성  
특정 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL 이 될 수 없다는 제약 조건이다.

# 4.4 데이터베이스의 종류  
## 4.4.1 관계형 데이터 베이스 (RDBMS, Relational Database Management System)
**정의**: RDBMS는 행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스를 가르키며 SQL 이라는 언어를 써서 조작한다.  
**예시**: SQL Server, MS SQL, My SQL, Oracle 등  
💡데이터 구조가 명확하여 변경될 여지가 없으며 명확한 스키마가 중요한 경우 사용하는 것이 좋다.  
**장점**
- 정해진 스키마에 따라 데이터를 저장하여야 하므로 명확한 데이터 구조를 보장한다.
- 각 데이터를 중복없이 한 번만 저장할 수 있다.  

**단점**  
- 시스템이 커질 경우 JOIN 문이 많은 복잡한 쿼리가 만들어 질 수 있다.  
- 스키마로 인해 데이터가 유연하지 못하다.  
## 4.4.2 NoSQL 데이터베이스 (Not Only SQL)
**정의**: SQL 을 사용하지 않는 데이터베이스를 말한다.  
**예시**: MongoDB 와 redis 등  
💡정확한 데이터 구조를 알 수 없고 데이터가 변경 및 확장이 될 수 있는 경우에 사용하는 것이 좋다.  
**장점**  
- NoSQL 에서는 스키마가 없기 때문에 유연하며 자유로운 데이터 구조를 가질 수 있다.  
- 언제든 저장된 데이터를 조정하고 새로운 필드를 추가할 수 있다.
- 데이터 분산이 용이하다.  

**단점 ** 
- 데이터 중복이 발생할 수 있다.  
- 스키마가 존재하지 않기에 명확한 데이터 구조를 보장하지 않으며 데이터 구조 결정이 어려울 수 있다.
# 4.5 인덱스
## 4.5.1 인덱스의 필요성
### 인덱스란?
인덱스는 데이터를 빠르게 찾을 수 있는 하나의 장치이다. 인덱스를 설정하면 테이블 안에 내가 찾고자 하는 데이터를 빠르게 찾을 수 있다.  
- 특정 컬럼에 인덱스를 생성하면, 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장된다.    
> ✔️**인덱스의 장점**
> - 인덱스 테이블은 데이터들이 정렬되어 저장되어 있기 때문에 해당 조건 (where)에 맞는 데이터들을 빠르게 찾을 수 있다.   
> ✔️**인덱스의 단점**  
> - INSERT, UPDATE, DELETE 를 통해 데이터가 추가되거나 값이 바뀌면 인덱스 테이블 내에 있는 값들을 다시 정렬해야 한다. 

### 인덱스 종류 [🔎](https://junghn.tistory.com/entry/DB-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0-%EC%9D%B8%EB%8D%B1%EC%8A%A4%EC%99%80-%EB%84%8C%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EA%B0%9C%EB%85%90-%EC%B4%9D%EC%A0%95%EB%A6%AC)  
#### 클러스트형 인덱스  
- 행 데이터를 인덱스로 지정한 열에 맞춰서 자동 정렬한다.  
- 테이블 당 한 개만 생성할 수 있다.  
#### 비클러스트형 인덱스  
- 테이블 당 여러 개의 인덱스를 생성할 수 있다.
- 인덱스 자체의 리프 페이지는 데이터가 아니라 데이터가 위치하는 포인터이기 때문에 클러스트형보다 검색 속도는 더 느리지만, <u>데이터의 입력, 수정, 삭제는 더 빠르다.</u>  


## 4.5.2 B-트리
인덱스는 보통 B- 트리 라는 자료 구조로 이루어져 있다.
최상단 노드인 `루트 노드`, 중간 노드들을 `브랜치 노드` , 가장 아래 노드들을 `리프 노드` 라고 한다.  

- 인덱스가 효율적인 이유는 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 <u>균형 잡힌 트리 구조</u>와 <u>트리 깊이의 **대수확장성**</u> 때문이다.  
- 대수확장성 : 트리 깊이가 리프 노드 수 에 비해 매우 느리게 성장하는 것을 의미한다.    

### B+Tree
기존의 B-Tree 는 어느 한 데이터의 검색은 비효율적이지만, 모든 데이터를 한 번 순회하는 데에는 트리의 모든 노드를 방문해야 하므로 비효율적이다. 이러한 B-Tree 의 단점을 개선시킨 자료구조가 B+Tree 이다.  
- 오직 리프노드에만 데이터를 저장하고 그 외 노드에는 자식 포인터만 저장한다.  
- 리프 노드들끼리는 Linked List로 연결되어 있다.  
- 하나의 Node 에 더 많은 포인터를 가질 수 있기 때문에 트리의 높이가 더 낮아지므로 검색 속도를 높일 수 있다.

## 4.5.3 인덱스 만드는 방법
#### 인덱스 생성
```
CREATE INDEX [인덱스명] ON [스키마.테이블명](컬럼명 ASC | DESC)
```
#### 인덱스 삭제
```
DROP [인덱스명] ON [스키마.테이블명]
```

💡<U>인덱스를 변경하는 명령은 없다! 인덱스를 삭제하고 재생성해야 한다!</U>  

## 4.5.4 인덱스 최적화 기법

✔️생성된 인덱스를 효율적으로 사용하기 위해 고려 사항
- 조건절(WHERE)에 자주 등장하는 컬럼  
- 중복되는 데이터가 최소한인 컬럼 (분포도가 좋은 컬럼) 
- JOIN 조건으로 자주 사용되는 컬럼
- 가장 최선은 pk로 인덱스를 거는 것이다.
- 복합 인덱스는  `=` / `ORDER BY` / `<` `>`/`카니널리티` 순으로 생성 => 생성 순서에 따라 인덱스 성능이 달라진다.

# 4.6 조인의 종류
**정의**  
하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것을 말한다.     
💡ex) MySQL 에서는 **JOIN **이라는 쿼리로, MongoDB에서는** lookup **이라는 쿼리로 이를 처리할 수 있다.   
💡단, MongoDB는 조인 연산( lookup) 에 대해 RDBMS 보다 성능이 떨어지므로 되도록 사용하지 말아야  한다.   

**종류  **  
- 내부 조인 Inner Join
- 왼쪽 조인 Left Join
- 오른쪽 조인 Right Join
- 합집합 조인 Full outer Join    

## 내부 조인  
A 테이블과 B 테이블의 두 행이 모두 일치하는 행이 있는 부분만 출력된다. =>`교집합`  

## 왼쪽 조인  
A를 기준으로 완전한 레코드 집합과 테이블 B의 일치하는 부분의 레코드와 함께 집합을 생성한다.    
B 에 일치하는 항목이 없으면 해당 값은 => null 값  
## 오른쪽 조인 
B를 기준으로 완전한 레코드 집합과 테이블 A의 일치하는 부분의 레코드와 함께 집합을 생성한다.    
A 에 일치하는 항목이 없으면 해당 값은 => null 값  
## 합집합 조인 
양쪽 테이블에 일치하는 레코드와 A와 B의 모든 레코드의 집합  
일치하는 항목이 없으면 누락된 쪽에 => null 값 

 

# 4.7 조인의 원리

[참고🔎](https://dataonair.or.kr/db-tech-reference/d-guide/sql/?mod=document&uid=356)

## 중첩 루프 조인 (NLJ, Nested Loop Join) 
중첩 for 문과 같은 원리로 조건에 맞는 조인을 하는 방법이다.  
- 반복문의 외부에 있는 테이블을 `선행 테이블` 또는 `외부 테이블(Outer Table)` 이라고 한다.  
- 반복문의 내부에 있는 테이블을 `후행 테이블` 또는 `내부 테이블 (Inner Table)` 이라고 한다.
## 정렬 병합 조인 (Sort Merge Join)
각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행하는 조인이다. 
- 조인 시 적절한 인덱스가 없고 대용량의 테이블들을 조인하고 조인 조건으로 `>` , `<` 등의 범위 비교 연산자가 있을 때 쓰인다. 


## 해시 조인

조인을 수행할 테이블의 조인 칼럼을 기준으로 해쉬 함수를 수행하여 서로 동일한 해쉬 값을 갖는 것들 사이에서 실제 값이 같은지를 비교하면서 조인을 수행한다.
