# 데이터베이스의 종류
## 관계형 데이터베이스(RDBMS)
행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스를 가리키며, SQL이라는 언어를 써서 조작합니다.   
관계형 데이터베이스의 경우 표준 SQL은 지키지만, 각각의 제품에 특화시킨 SQL을 사용합니다.

### MySQL
대부분의 운영체제와 호환되며, 현재 가장 많이 사용하는 데이터베이스입니다.   
C, C++로 만들어졌으며, MyISAM 인덱스 압축 기술, B-트리 기반의 인덱스, 스레드 기반의 메모리 할당 시스템, 매우 빠른 조인, 최대 64개의 인덱스를 제공합니다. 대용량 데이터베이스를 위해 설계되어 있고 롤백, 커밋, 이중 암호 지원 보안 등의 기능을 제공하며, 많은 서비스에서 사용합니다.

### PostgreSQL
디스크 조각이 차지하는 영역을 회수할 수 있는 장치인 VACUUM이 특징입니다. 최대 테이블의 크기는 37TB이며, SQL뿐만 아니라 JSON을 이용해 데이터에 접근할 수 있습니다.

## NoSQL(Not Only SQL) 데이터베이스
SQL을 사용하지 않는 데이터베이스를 말하며, 대표적으로 MongoDB와 redis 등이 있습니다.

### MongoDB
JSON을 통해 데이터에 접근할 수 있고, Binary JSON 형태(BSON)로 데이터가 저장되며, 와이어드타이거 엔진이 기본 스토리지 엔진으로 장착된, 키-값 데이터 모델에서 확장된 도큐먼트 기반의 데이터베이스입니다.   
확장성이 뛰어나며 빅데이터를 저장할 때 성능이 좋고, 고가용성과 샤딩, 레플리카셋을 지원합니다. 또한, 스키마를 정해 놓지 않고 데이터를 삽입할 수 있기 때문에 다양한 도메인의 데이터베이스를 기반으로 분석하거나 로깅 등을 구현할 때 강점을 보입니다.

### redis
인메모리 데이터베이스이자 키-값 데이터 모델 기반의 데이터베이스입니다.   
기본적인 데이터 타입은 문자열(string)이며 최대 512MB까지 저장할 수 있습니다. 이외에도 셋(set), 해시(hash) 등을 지원합니다.

# 인덱스
## 인덱스의 필요성
인덱스는 데이터를 빠르게 찾을 수 있는 하나의 장치입니다. 인덱스를 설정하면 테이블 안에 내가 찾고자 하는 데이터를 빠르게 찾을 수 있습니다.

## B-트리
B-트리는 루트 노드, 리프 노드, 그리고 루트 노드와 리프 노드 사이에 있는 브랜치 노드로 나뉩니다.   
트리 탐색은 맨 위 루트 노드부터 탐색이 일어나며, 브랜치 노드를 거쳐 리프 노드까지 내려옵니다.

### 인덱스과 효율적인 이유와 대수확장성
인덱스를 사용하면 효율적인 단계를 거쳐 모든 요소에 접근할 수 있는 균형 잡힌 트리 구조와 트리 깊이의 대수확장성 때문입니다.
> ###### 대수확장성
> 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것

## 인덱스를 만드는 방법
데이터베이스에 따라 다릅니다.

### MySQL
클러스터형 인덱스와 세컨더리 인덱스가 있습니다.   
> ###### 클러스터형 인덱스
> 테이블당 하나를 설정할 수 있습니다. primary key 옵션으로 기본키를 만들거나, 기본키로 만들지 않고 unique not null 옵션을 붙이면 클러스터형 인덱스로 만들 수 있습니다.
> ###### 세컨더리 인덱스
> create index... 명령어를 기반으로 만들면 세컨더리 인덱스를 만들 수 있습니다.
하나의 인덱스만 생성할 것이라면 클러스터형 인덱스를 만드는 것이 세컨더리 인덱스를 만드는 것보다 성능이 좋습니다. 세컨더리 인덱스는 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스입니다.

### MongoDB
도큐먼트를 만들면 자동으로 ObjectID가 형성되며, 해당 키가 기본키로 설정됩니다. 그리고 세컨더리키도 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 복합 인덱스를 설정할 수 있습니다.

## 인덱스 최적화 기법
데이터베이스마다 조금씩 다르지만 기본적인 골조는 똑같기 때문에 특정 데이터베이스를 기준으로 설명해도 무방합니다.   
여기서는 MongoDB를 기반으로 설명합니다.

### 1. 인덱스는 비용이다
먼저, 인덱스는 두 번 탐색하도록 강요합니다. 인덱스 리스트, 그다음 컬렉션 순으로 탐색하고, 관련 읽기 비용이 들게 됩니다.   
또한, 컬렉션이 수정되면 인덱스도 수정되어야 합니다. 이때 B-트리의 높이를 균형 있게 조절하는 비용도 들고, 데이터를 효율적으로 조회할 수 있도록 분산시키는 비용도 들게 됩니다.

### 2. 항상 테스팅하라
서비스에서 사용하는 객체의 깊이, 테이블의 양 등이 다르기 때문에 서비스 특징에 따라 최적화도 달라집니다. 그렇기 때문에 항상 테스팅하는 것이 중요합니다.

### 3. 복합 인덱스는 같음, 정렬, 다중 값, 카디널리티 순이다
보통 여러 필드를 기반으로 조회할 때 복합 인덱스를 생성하는데, 이 인덱스를 생성할 때는 순서가 있고, 생성 순서에 따라 인덱스 성능이 달라집니다.
- 1. 어떠한 값과 같음을 비교하는 쿼리가 있다면 제일 먼저 인덱스로 설정합니다.
- 2. 정렬에 쓰는 필드라면 그다음 인덱스로 설정합니다.
- 3. 쿼리 자체가 >이거나 < 등 많은 값을 출력해야 하는 쿼리에 쓰는 필드라면 나중에 인덱스를 설정합니다.
- 4. 카디널리티(유니크한 값의 정도)가 높은 순서를 기반으로 인덱스를 생성해야 합니다.

# 조인의 종류
조인이란 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것을 말합니다.   
MongoDB는 lookup 쿼리를 통해 조인을 실행하는데, 해당 쿼리의 연산이 떨어지기 때문에 여러 테이블을 조인하는 작업이 많은 경우 관계형 데이터베이스를 써야 합니다.   
조인은 내부 조인, 왼쪽 조인, 오른쪽 조인, 합집합 조인 네 가지가 있습니다.

> ###### 내부 조인
> 왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기   
> ```
> SELECT * FROM TableA A   
> INNER JOIN TableB B ON   
> A.key = B.key   
> ```
> ###### 왼쪽 조인
> 왼쪽 테이블의 모든 행이 결과 테이블에 표기
> ```
> SELECT * FROM TableA A
> LEFT JOIN TableB B ON
> A.key = B.key
> ```
> ###### 오른쪽 조인
> 오른쪽 테이블의 모든 행이 결과 테이블에 표기
> ```
> SELECT * FROM TableA A
> RIGHT JOIN TableB B ON
> A.key = B.key
> ```
> ###### 합집합 조인
> 두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기
> ```
> SELECT * FROM TableA A
> FULL OUTER JOIN TableB B ON
> A.key = B.key
> ```

# 조인의 원리
앞서 설명한 조인들은 조인의 원리를 기반으로 조인 작업이 이루어집니다.

## 중첩 루프 조인 (NLJ, Nested Loop Join)
중첩 for 문과 같은 원리로 조건에 맞는 조인을 하는 방법이며, 랜덤 접근에 대한 비용이 많이 증가하므로 대용량의 테이블에서는 사용하지 않습니다.   
참고로 중첩 루프 조인에서 발전한, 조인할 테이블을 작은 블록으로 나눠서 블록 하나씩 조인한느 블록 중첩 루프 조인(BNL, Block Nested Loop)이라는 방식도 있습니다.

## 정렬 병합 조인
각각의 테이블을 조인할 필드 기준으로 정렬하고, 정렬이 끝난 이후에 조인 작업을 수행하는 조인입니다.   
조인할 때 쓸 적절한 인덱스가 없고, 대용량의 테이블들을 조인하고, 조인 조건으로 <. > 등 범위 비교 연산자가 있을 때 씁니다.

## 해시 조인
해시 테이블을 기반으로 조인하는 방법입니다. 동등(=) 조건에서만 사용할 수 있습니다.   
해시 조인 단계는 빌드 단계, 프로브 단계로 나뉩니다. (MySQL)

### 빌드 단계
입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계입니다. 두 테이블 중 바이트가 더 작은 테이블을 기반으로 해서 해시 테이블을 빌드합니다.

### 프로브 단계
레코드 읽기를 시작하며, 각 레코드에서 키에 일치하는 레코드를 찾아 결괏값으로 반환합니다.












