# CHAPTER 1. 디자인 패턴과 프로그래밍 패러다임

## SECTION 1. 디자인 패턴

### 디자인 패턴

프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 '규약' 형태로 만들어 놓은 것

### 싱클톤 패턴

- 하나의 클래스에 하나의 인스턴스만 생성하고, 이 인스턴스를 여러 모듈에서 공유하는 형태로
  주로 데이터 베이스 연결 모듈에 사용
- 장점 : 하나의 인스턴스만 생성하기 때문에 자원(비용)이 적게 소요
- 단점 : 의존성이 높아짐</br>
  예를들어 TDD(Test Driven Development)를 할 때 단위 테스트를 진행하게 되면
  테스트를 진행할 모듈들이 서로 독립적이어야 하며, 어떤 순서로도 실행이 가능해야 함.
  하지만 인스턴스를 공유하기 때문에 단위 실행 순서에 따라 인스턴스의 어트리뷰트는 변할 수 있으므로 TDD는 불가능함

> **의존성 주입 (DI, Dependency Injection)** </br>
> 의존성 문제를 해결하기 위해 의존성 주입을 하기도 함
> 메인 모듈이 '직접' 다른 하위 모듈에 대한 의존성을 주기보다는 중간에 의존성 주입자가 이 부분을 가로채 메인 모듈이 '간접'적으로 의존성을 주입하는 방식
> 이를 통해 모듈을 쉽게 교체할 수 있는 구조가 되어 단위 테스트가 쉬워지는 등 장점이 있으나, 코드의 복잡성이 증가함

### 팩토리 패턴

- 객체를 생성하는 부분을 떼어내 추상화하는 패턴
- 상속관계에 있는 두 개의 클래스에서 상위 클래스에서는 뼈대를 결정하고, 하위 클래스에서는 객체를 생성하기 위한 세부 내용을 결정
- 의존성 주입과 같은 맥락으로, 상위 클래스가 하위 클래스와 분리되며 느슨한 결합을 가짐 (상위 클래스에서는 뼈대만 만들어주면 되기 때문에 객체가 실제로 어떻게 생성되는지는 전혀 관여하지 않게 됨)
- 객체를 생성 시에 세부사항만 살짝 바꿔줄 일이 있다면 하위 클래스 객체만 수정하면 되기 때문에 유지보수성이 증가함

</br>

> [JS] 정적 메서드를 쓰면 클래스의 인스턴스 없이 호출이 가능하여 메모리를 절약할 수 있고, 개별 인스턴스에 묶이지 않으며 클래스 내의 함수를 정의할 수 있는 장점이 있음 </br>
> ex. CoffeeFactory에서 static으로 createCoffee() 정적 메서드를 정의함

```javascript
class Latte {
  constructor() {
    this.name = "latte";
  }
}

class Espresso {
  constructor() {
    this.name = "Espresso";
  }
}

class LatteFactory {
  static createCoffee() {
    return new Latte();
  }
}
class EspressoFactory {
  static createCoffee() {
    return new Espresso();
  }
}
const factoryList = { LatteFactory, EspressoFactory };

class CoffeeFactory {
  static createCoffee(type) {
    const factory = factoryList[type];
    return factory.createCoffee();
  }
}
const main = () => {
  // 라떼 커피를 주문한다.
  const coffee = CoffeeFactory.createCoffee("LatteFactory");
  // 커피 이름을 부른다.
  console.log(coffee.name); // latte
};
main();
```

### 전략 패턴

- 객체 행위를 바꾸고 싶은 경우, 객체를 직접 수정하지 않고 전략이라 부르는 '캡슐화한 알고리즘'을 컨텍스트 안에서 바꿔주어 상호 교체가 가능하게 만드는 패턴
- 예를 들어 어떤 상품을 구매할 때 네이버페이, 카카오페이 등 다양한 방법으로 결제하듯이, 결제 방식의 '전략'만 바꿔서 두 가지 방식으로 결제하는 것을 구현할 수 있음

### 옵저버 패턴

- 주체, 대상 객체, 옵저버로 이루어진 패턴
- 대상 객체의 상태 변화를 주체가 계속 관찰하면서, 객체에 변화가 생길 때마다 메서드 등을 통해 옵저버들에게 변화를 알려주는 패턴
- EX) 트위터 => A라는 사람(주체 + 대상 객체)이 글을 올리면(대상 객체의 변화), 팔로우한 사람들(옵저버)에게 알림이 가는 형식

#### JS에서의 옵저버 패턴

- JS에서 옵저버 패턴은 프록시 객체를 통해 구현 가능
- 프록시 객체 : 어떠한 대상의 기본적인 동작(속성 접근, 할당, 순회, 열거, 함수 호출 등)의 작업을 가로챌 수 있는 객체
  - 2개의 매개 변수
  - 1. target : 프록시할 대상
  - 2. handler : 프록시 객체의 target 동작을 가로채서 정의할 동작들이 정해져 있는 함수
  ```javascript
  const handler = {
    get: function (target, name) {
      return name === "name" ? `${target.a} ${target.b}` : target[name];
    },
  };
  const p = new Proxy({ a: "KUNDOL", b: "IS AUMUMU ZANGIN" }, handler);
  console.log(p.name); // KUNDOL IS AUMUMU ZANGIN
  ```

> **프록시 객체를 이용한 옵저버 패턴** </br>
> 프록시 객체의 get()함수는 속성과 함수에 대한 접근을 가로채며, has() 함수는 in 연산자의 사용을 가로챔. set()함수는 속성에 대한 접근을 가로챔. set() 함수를 통해 속성에 대한 접근을 '가로채'서 형규라는 속성이 솔로에서 커플로 되는 것을 감시할 수 있었음.

```javascript
function createReactiveObject(target, callback) {
  const proxy = new Proxy(target, {
    set(obj, prop, value) {
      if (value !== obj[prop]) {
        const prev = obj[prop];
        obj[prop] = value;
        callback(`${prop}가 [${prev}] >> [${value}] 로 변경되었습니다. `);
      }
      return true;
    },
  });
  return proxy;
}
const a = { 형규: "솔로" };
const b = createReactiveObject(a, console.log);
b.형규 = "솔로";
b.형규 = "커플";
// 형규가 [솔로] >> [커플] 로 변경되었습니다.
```

### 프록시 패턴

- 대상 객체에 접근하기 전, 그 객체에 접근하기 위한 흐름을 가로채면서, 그 객체 앞단에서 인터페이스 역할을 하는 패턴
- EX) node.js에서 nginx을 서버 앞단에 배치하여 프록시 서버로 활용

> **프록시 서버** </br>
> 서버와 클라이언트 사이에서, 클라이언트가 자신을 통해 네트워크에 간접적으로 접속할 수 있는 컴퓨터 시스템이나 응용프로그램

#### CORS와 프론트엔드의 프록시 서버

- CORS(Cross-Origin Resource Sharing)는 서버가 웹 브라우저에서 리소스를 로드할 때 다른 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘
- 프론트엔드 개발 시 프론트엔드 서버를 만들어서 백엔드 서버와 통신할 때 주로 CORS 에러를 마주치는데, 이를 해결하기 위해 프론트엔드에서 프록시 서버를 만들기도 함

### 이터레이터 패턴

- 이터레이터 패턴은 이터레이터 객체를 이용해 이터러블한 콜렉션 요소들에 접근하는 패턴
- 이터러블한 객체기만 하면 하나의 인터페이스로 순회가 가능

### 노출모듈 패턴

- 즉시 실행함수를 통해 private, public 같은 접근 제어자를 만드는 패턴
- JS는 private나 public 같은 접근 제어자가 존재하지 않고 전역 범위에서 스크립트가 실행되기 때문에 노출 모듈 패턴을 통해 private와 public 접근 제어자를 구현하기도 함

> **CJS (CommonJS)** </br>
> 노출모듈 패턴을 기반으로 만든 자바스크립 모듈 방식

### MVC 패턴

- 모델(Model), 뷰(View), 컨트롤러(Controller)로 이루어진 디자인 패턴
- 어플리케이션의 구성 요소들을 이 세 가지로 나눔으로써, 설계 시 개별 요소에 더 집중할 수 있는 장점
- MVC 패턴을 이용한 대표적인 라이브러리 : React.js

#### 모델

- 어플리케이션의 데이터베이스, 상수, 변수 등의 **데이터**를 의미

#### 뷰

- 모델을 구성하는 데이터를 추가/삭제/변경할 수 있는 인터페이스 요소
- 보통은 사용자가 볼 수 있는 GUI를 의미
- 뷰는 데이터를 따로 저장할 수 있는 기능이 없어야 하며, 모델만 데이터를 따로 가지고 있을 수 있음
- 따라서 **뷰는 엄밀한 의미에서 단순히 모델에 있는 데이터를 보여주기만 할 뿐**
- 이에 따라 뷰는 모델에 대응되며, 높은 의존성을 가짐

#### 컨트롤러

- **모델과 뷰를 이어주는 역할**을 하는 구성요소
- 사용자가 뷰와 상호작용하면서 모델에 있는 데이터가 변경되도록 로직을 구성
- 모델과 뷰의 생명 주기도 관리하며 모델이나 뷰의 변경 알림을 받을 경우 이를 해석해 관련된 구성 요소에 전달

### MVP 패턴

- MVC 패턴에서 C가 presenter로 변경된 패턴
- 이 패턴에서는 Model과 View 분리되어 있고 오직 Presenter를 통해서 상태나 변화를 알려줄 수 있음
- MVC와 달리 Presenter와 View는 1:1 관계이다.
- 따라서 View와 Model간 의존성은 줄었으나, Presenter와 View의 의존성이 높아지는 문제가 있다.

### MVVM 패턴

- MVC패턴에서 C가 뷰모델(view model)로 변경된 패턴
- 뷰모델은 뷰를 더 추상화하여, 커멘드와 데이터 바인딩(화면의 데이터와 웹 브라우저의 메모리 데이터를 일치시키는 기법)을 가지게 됨
- 대표적인 프레임워크 : Vue.js

</br>

---

</br>

## SECTION 2. 프로그래밍 패러다임

### 프로그래밍 패러다임

프로그래밍 패러다임은 프로그래밍을 어떤 원칙으로 할지 정하고, 이 원칙에 따른 설계 관점을 프로그래머가 갖출 수 있도록 하는 개발 방법론

> **프로그래밍 패러다임 종류**
>
> - 선언형
>   - 함수형
> - 명령형
>   - 객체지향형
>   - 절차지향형

#### 선언형 프로그래밍과 명령형 프로그래밍

- **선언형 프로그래밍**은 무엇을(What) 할 것인지에 집중한 패러다임</br>
  > 목표를 명시하고 알고리즘을 명시하지 않음 </br>
  > 출발 : 경기도 성남시 분당구 성남대로 333,  
  > 도착 : 네이버 주소는 경기도 성남시 분당구 불정로 6.
- **명령형 프로그래밍**은 어떻게(HOW) 할 것인지 집중한 패러다임 </br>
  > 알고리즘은 명시하고 목표는 명시하지 않음 </br>
  > 1. 횡단보도까지 약 99m 이동(성남대로331번길),
  > 2. 횡단보도를 이용하여 경기성남분당경찰서 방면으로 횡단,
  > 3. 횡단보도까지 1개의 횡단보도를 지나 약 612m 이동,
  > 4. 횡단보도를 이용하여 메르세데스... 방면으로 횡단,
  > 5. 네이버까지 약 50m 이동(불정로).

### 선언형과 함수형 프로그래밍

- **선언형 프로그래밍**은 무엇을(What) 할 것인지에 집중한 패러다임
- 함수형 프로그래밍은 작은 '순수 함수'들을 블록처럼 쌓아 로직ㄱ을 구현하고 '고차함수'를 통해 재사용성을 높인 프로그래밍 패러다임
- JS는 단순하고 유연한 언어이며, 함수가 일급 객체이기 때문에 객체지향 프로그래밍 보다는 함수형 프로그래밍 방식이 선호됨

> 함수형 프로그래밍으로 최대값을 구하는 예시코드 </br>
> ```javascript
> const ret = [1, 2, 3, 4, 5, 11, 12].reduce(
>   (max, num) => (num > max ? num : max),
>   0
> );
> console.log(ret); // 12
> ```

#### 순수 함수

- **출력이 입력에만 의존**하는 함수를 의미

```javascript
const pure = (a, b) => {
  return a + b;
};
```

#### 고차 함수

- 함수가 함수를 매개변수로 받아 로직을 생성할 수 있는 것
- 고차함수를 통해 함수를 중첩해 하나의 프로그램으로 설계할 수 있음

> **일급객체 (first class)**</br>
> 고차 함수를 쓰기 위해서는 프로그래밍 언어에서 아래 조건을 만족해야 하며, 이를 일급 객체 특징을 가짐 </br>
> - 변수나 메서드에 함수를 할당할 수 있다.
> - 함수 안에 함수를 매개 변수로 담을 수 있다.
> - 함수가 함수를 반환할 수 있다.

### 객체지향 프로그래밍

- 객체의 집합으로 프로그램의 상호작용을 표현하는 패러다임

> 객체지향 프로그래밍으로 최대값을 구하는 예시코드</br>
> ```javascript
> const ret = [1, 2, 3, 4, 5, 11, 12];
> class List {
>   constructor(list) {
>     this.list = list;
>     this.mx = list.reduce((max, num) => (num > max ? num : max), 0);
>   }
>   getMax() {
>     return this.mx;
>   }
> }
> const a = new List(ret);
> console.log(a.getMax()); // 12
> ```

### 객체지향 프로그래밍의 특징

### 추상화

- 복잡한 시스템에서 공통으로 필요로 하는 핵심적인 기능과 개념을 간추려 표현하는 것
- 이를 통해 설계의 유연함을 갖출 수 있음 </BR>
  EX) 예를 들어 세부적인 기능 구현은 건너 뛰고 공통적으로 적용되는 뻐대만을 우선 구현할 수도 있음

#### 자료 추상화

- 불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 프로그램을 간단히 만드는 것
- 자료 추상화를 통해 정의된 자료형을 추상 자료형이라 함
- 추상 자료형은 자료형의 자료 표현과 자료형의 연산을 캡슐화한 것으로 접근 제어를 통해서 자료형의 정보를 은닉할 수 있음
- 객체 지향 프로그래밍에서 일반적으로 추상 자료형을 클래스, 추상 자료형의 인스턴스를 객체, 추상 자료형에서 정의된 연산을 메소드(함수), 메소드의 호출을 생성자라고 함

#### 캡슐화

- 객체의 속성과 메서드를 하나로 묶고 외부에서 접근하지 못하도록 은닉하는 것

#### 상속성

- 상위 클래스의 특성을 하위 클래스가 이어받아 재사용할 수 있도록 하는 것
- 이를 통해 계층적인 관계 생성이 가능하며, 유지 보수가 쉬워짐
- 예를 들어 사람이라는 상위 클래스를 만든 후, A라는 사람을 객체로 만들 때, 사람으로서 공통적인 특징은 그대로 상속받고, 고유한 A만의 특성을 따로 정의하여 재사용하는 것

#### 다형성

- 하나의 메서드나 클래스를 다양한 방법으로 동작하도록 하는 것

#### 오버로딩

- 같은 이름을 가진 메서드를 매개 변수의 유형/개수/타입이 다르게 하여 여러 개 가질 수 있는 것

#### 오버라이딩

- 상위 클래스에서 상속받은 메서드를 하위 클래스에서 재정의 하는 것

### 설계 원칙

- 객체지향 프로그래밍을 설계할 때는 SOLID 원칙을 지켜줘야 함

#### 단일 책임 원칙 (S)

- 모든 클래스는 각각 하나의 책임만을 가져야 하는 원칙

#### 개방-폐쇄 원칙 (O)

- 유지 보수 사항이 생길 경우, 쉽게 확장할 수 있도록 개방하되, 수정 시에는 닫혀 있어야 하는 원칙
- 기존 코드를 변경하지 않으면서 수정과 확장이 용이해야 한다고도 표현함

#### 리스코프 치환 원칙 (L)

- 프로그램의 정확성을 깨트리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 하는 것
- 부모의 객체에 자식 객체를 넣어도 시스템이 문제 없이 돌아가야 함

#### 인터페이스 분리 원칙 (I)

- 하나의 인터페이스보다 구체적으로 여러 개 인터페이스를 만들어야 하는 원칙

#### 의존 역전 원칙 (D)

- 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 원칙
- 상위 계층은 하위 계층위 변화에 대한 구현으로 부터 독립해야 한다

### 절차형 프로그래밍

- 일이 진행되는 방식으로 코드를 구현하는 것

> 절차형 프로그래밍으로 최대값을 찾는 예시 <br/>
> ```javascript
> const ret = [1, 2, 3, 4, 5, 11, 12];
> let a = 0;
> for (let i = 0; i < ret.length; i++) {
>   a = Math.max(ret[i], a);
> }
> console.log(a); // 12
> ```
