# 01. 디자인 패턴

프로그램을 설계할 때 발생하는 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 '규약' 형태로 만들어 놓은 것을 의미함
<br/><br/>

# 1. 싱글톤 패턴

개념: 하나의 클래스에 오직 <b>하나의 인스턴스만</b>을 가지는 패턴

사용방식: 데이터베이스 연결 모듈에 많이 사용됨

장점: 하나의 인스턴스를 만들어 놓고 해당 인스턴스를 다른 모듈이 공유하여 사용하기 때문에 인스턴스 생성할 때 드는 비용이 줄어든다.

단점: 모듈간 결합이 강하다.

TDD(Test Driven Development)를 할 때 단위 테스트를 주로 하는데 단위 테스트는 테스트가 서로 독립적이어야 어떤 순서로든 실행 할 수 있다. 싱글톤 패턴의 하나의 인스턴스를 기반으로 구현하는 특성 때문에 테스트 마다 '독립적인' 인스턴스를 만들기 어려워 TDD 할 때 걸림돌이 된다.

개선안 : <b>의존성 주입</b>

A가 B에 의존성이 있다는 것은 B에 변하면 A도 변해야 된다는 뜻
메인 모듈이 '직접적'으로 다른 하위 모듈에 의존성을 주지 않고 중간에서 '의존성 주입자'가 이 부분을 가로채 메인 모듈이 '간접적'으로 의존성을 주입하는 방식

장점: 모듈 교체가 쉬워져 테스팅과 마이그레이션이 쉽고, 모듈 간의 관계가 명확해진다

단점: 복잡성이 증가되고 약간의 런타임 페널티가 생긴다

# 2. 팩토리 패턴

개념: 객채 생성 부분을 떼어네 추상화한 패턴이자 상속 관계에 있는 두 클래스에서 <b>상위 클래스가 중요한 뼈대를 결정</b>하고 <b>하위 클래스에서 객체 생성에 대한 구체적인 내용</b>을 결정

장점: 상위 클래스와 하위 클래스가 분리되기 때문에 느슨한 결합을 가지며 유지 보수성이 증가된다

# 3. 전략 패턴

개념: 객체의 행위를 바꾸고 싶은 경우 '직접' 수정하지 않고 전략이라고 부르는 캡슐화한 알고리즘'을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 하는 패턴

사용방식: 여러 카드에 대한 결제 방식, 인증 모듈을 구현하는 passport 라이브러리

# 4. 옵저버 패턴

개념: 주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 떄마낟 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 패턴

주체(관찰자) <> 옵저버들(객체 상태 변화에 따라 추가 변화 사항이 생기는 객체들)

사용방식: 트위터에서 새로운 트윗을 팔로우(옵저버들)에게 알려준다, Vue.js 3.0

## 자바에서 옵저버 채턴

상속과 구현<hr/>

상속(extends): 자식 클래스가 부모 크래스의 메서드를 상속 받아 자식 클래스에서 추가 및 확장을 할 수 있는 것

구현(implements): 부모 인터페이스를 자식 클래스에서 재정의하여 구현하는 것

-> 상속을 일반 클래스, abstract 클래스를 기반으로, 구현은 인터페이스 기반으로 구현

## 자바스크립트에서 옵저버 패턴

프록시 객체를 통해 구현 가능<hr/>

프록시 객체: 어떠한 대상의 기본적인 동작(속성 접근, 할당, 순회, 열거, 함수 호출) 의 작업을 가로챌 수 있는 객체를 뜻함.

자바스크립트에서 프록시 객체는 두 개의 매개 변수를 가짐

target: 프록시할 대상

handler: 프록시 객체의 target 동작을 가로채서 정의할 동작들이 정해져 있는 함수
<br/>
<br/>

프록시 객체를 구현한 코드

```js
const handler = {
  get: function (target, name) {
    return name === 'name' ? `${target.a} ${target.b}` : target[name];
  },
};

const p = new Proxy({ a: 'KIM', b: 'is my last name' }, handler);

console.log(p.name); // KIM is my last name
```

# 5. 프록시 패턴과 프록시 서버

## 프록시 패턴

개념: 대상 객체(subject)에 접근하기 전 그 <b>접근에 대한 흐름</b>을 가로채 앞단의 인터페이스 역할을 하는 디자인 패턴. 이를 통해 객체의 속성, 변환을 보완하여 보안, 데이터 검증, 캐싱, 로깅에 사용함.

사용방식: 프록시 서버

## 프록시 서버

서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 하는 응용 프로그램을 가리킴

nginx: 웹서버로 주로 Node.js 서버의 앞단의 프록시 서버로 활용됨. 이는 Node.js의 버퍼 오버플로우 취약점을 예방할 수 있다. (버퍼는 데이터가 저장되는 메모리 공간으로, 메모리 공간을 벗어나면 버퍼 오버플로우라고 한다.)

CloudFlare
개념: 전 세계적으로 분산된 서버가 있고 이를 통해 어떠한 시스템의 콘텐츠 전달을 빠르게 할 수 있는 CDN 서비스이다.

장점: DDOS 공격 방어, HTTPS구축. 웹 서버 앞단에 두어 '프록시 서버'로 쓰기 때문이다

### CORS와 프론트엔드의 프록시 서버

CORS(Cross Origin Rescource Sharing)는 서버가 웹 브라우저에서 리소스를 로드할 때 오리진을 통해 로드하지 못하게 하는 HTTP 헤더 기반 메커니즘입니다.

오리진은 프로토콜, 호스트 이름, 포트의 조합이고 이것이 같아야 CORS 에러가 나타나지 않는다. 프록시 서버를 두면 여기서 포트번호를 바꿔주기 때문에 CORS 에러를 해결해주고, 다양한 API 서버와의 통신도 매끄럽게 해줌.

# 6. 이터레이터 패턴

이테레이터를 사용하여 컬랙션의 요소들에 접근하는 디자인 패턴

```js
const mp = new Map();
mp.set('a', 1);
mp.set('b', 2);
mp.set('c', 3);

for (let a of mp) console.lof(a);
```

위 코드에서 이터레이터 프로토콜은 'for a of mp' 이다.

# 7. 노출모듈 패턴

즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴을 의미함
자바스크립트는 접근제어자가 존재하지 않고 전역 범위에서 스크립트가 실행된다. 노출 모듈 패턴을 통해 public, private 접근 제어자 구현이 가능하다.

```js

const pukuba = () => {
  const a = 1;
  const b = () => 2;
  const public = {
    c: 2,
    d: () => 3,
  };
    return public
  }();

console.log(pukuba) // {c :2. d: [Function:d] }
console.log(pukuba.a)// undefined

```

<br/>
public: 클래스가 정의된 함수에서 접근 가능, 자식 클래스와 외부 클래스에서 접근 가능한 범위<br/>
protected: 클래스가 정의된 함수와 자식 클래스에서 접근 가능, 외부 클래스에서 접근 불가능한 범위 <br/>
private: 클래스가 정의된 함수에서 접근 가능, 지식 클래스와 외부 클래서에서 접근 불가능한 범위
<br/>
즉시 실행 함수: 함수를 정의하자마자 바로 호출하는 함수. 초기화 코드,라이브러리 내 전역 변수의 충동 방지에 사용된다.
<br/>
<br/>

# 8. MVC 패턴

개념: Model, View, Controller 로 이우어진 디자인 패턴. 애플리케이션의 구성 요소를 세 가지 역할로 구분하여 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발 할 수 있다.

<b>Model:</b> 데이터인 데이터베이스, 상수, 변수를 의미. 뷰에서 데이터를 생성하거나 수정하면 컨트롤러를 통해 모델을 생성하거나 갱신함.

<b>View:</b> 사용자 인터페이스 요소를 의미. 모델이 가지는 정보를 따로 저장하지 않아야 하고 화면에 표시하는 정보만 가지고 있어야 한다. 또한 변경이 일어나면 컨트롤러에 이를 전달해야 한다.

<b>Controller:</b> 모델과 뷰를 잇는 다리 역할을 하며 이벤트 등 메인 로직을 담당한다. 모델과 뷰의 생명주기도 관리한다.

사용방식: React.js

장점: 재사용성과 확장성에 용이하다

단점: 애플리케이션이 복작해질수록 모델과 뷰의 관계가 복잡해진다

# 9. MVP패턴

개념: Model, View, Presenter 로 이우어진 디자인 패턴. View 와 Presenter는 일대일 관계이기 때문에 MVC 패턴보다 더 강한 결합을 지녔다.

# 10.MVVM 패턴

개념: Model, View, ViewModel 로 이우어진 디자인 패턴. View Model은 View를 더 추상화한 계층이며, 커맨드와 데이터 바인딩을 가지는 것이 특징이다. 뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원한다.

사용방식: Vue.js

장점: UI를 별도로 코드 수정 없이 재사용 가능하고 단위 테스팅에 하기가 쉽다.
<br/><br/>
<br/><br/>

# 02. 프로그래밍 패러다임

프로그래밍 패러다임은 크게 선언형, 명령형으로 나누며, 선언형은 <b>함수형</b>, 명령형은 <b>객체지향형</b>, <b>절차지향형</b>으로 나눈다.
<br/><br/>

# 1. 함수형 프로그래밍(선언형)

개념: '프로그램은 함수로 이루어진 것이다' 라는 명제가 담긴 패러다임.
'순수 함수' 들을 불록처럼 쌓아 로직을 구현하고 '고차 함수'를 통해 재사용성을 높인 프로그램 패러다임

Ex) 자연수로 이루어진 배열에서 최댓값을 찾는 함수

```js
const ret = [1, 2, 3, 4, 5, 11, 12].reduce(
  (max, num) => (num > max ? num : max),
  0
);
console.log(ret); //12
```

순수함수: 출력이 입력에만 의존하는 것

고차함수: 함수가 함수를 매개변수로 받아 로직을 생성할 수 있는 것

- 변수나 메서드에 함수를 할당할 수 있다.
- 함수 안에 함수를 매개변수로 담을 수 있다.
- 함수가 함수를 반환 할 수 있다.

# 2. 객체지향형 프로그래밍(명령형)

객체들의 집합으로 프로그램의 상호작용을 표현하고 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식

단점: 설계에 많은 시간이 소요됨, 처리 속도가 다른 프로그래밍 패러다임에 비해 상대적으로 느림

Ex) 자연수로 이루어진 배열에서 최댓값을 찾는 로직
List라는 클래스를 만들고 a 라는 객체를 만들 때 최댓값을 추출해내는 메서드를 만듦

```js
const ret = [1, 2, 3, 4, 5, 11, 12]

class List {
    constructor(list){
        this.list = list
        this.mx = list reduce((max,min)=>num>max? num:max,0)
    }
    getMax(){
        return this.mx
    }
}
const a = new List(ret)
console.log(a.getMax()); //12
```

## 객체 프로그래밍의 특징

<hr>

<b>추상화</b>: 복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것

<b>캡술화</b>: 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것

<b>상속성</b>: 상위 클래스의 특성을 하위 클래스가 이어받아서 재사용하거나 추가, 확장하는 것

<b>다형성</b>: 하나의 메서드나 클래스가 다양한 방법으로 동작하는 것
ex) 오버로딩, 오버라이딩

## 객체 프로그래밍의 설계 원칙: SOLID

<hr>

<b>단일 책임 원칙</b>: 모든 클래스는 각각 하나의 책임만을 가져야하는 원칙

<b>개방 패쇄 원칙</b>: 기존의 코드는 잘 변경하지 않으면서 확장은 쉡게 할 수 있어야 한다

<b>리스코프 치환 원칙</b>: 부모 객체에 자식 객체를 넣어도 시스템이 문제없이 돌아가게 만드는 것

<b>인터페이스 분리 원칙</b>: 하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스를 만들어야 하는 원칙

<b>의존 역전 원칙</b>: 상위 계층은 하위 계층의 변화에 대한 구현으로부터 독립해야 한다

# 3. 절차지향형 프로그래밍

개념: 로직이 수행되어야 할 연속적인 계산 과정으로 이루어짐

장점: 코드 가독성이 좋고 실행 속도가 빠름, 계산이 많은 작업에 쓰임

단점: 모듈화 하기 어렵고 유지 보수성이 떨어짐

Ex) 자연수로 이루어진 배열에서 최댓값을 찾는 로직

```js

const ret = [1,2,3,4,5,11,12]
let a =0
for( let i =0 : i<ret.length; i++){
    a = Math.max(ret[i],a)
}
console.log(a) //12

```
