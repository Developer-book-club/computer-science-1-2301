# 1.디자인 패턴과 프로그래밍 패러다임
## 1.1디자인 패턴 
--------------------------
### 1.1.1 싱글톤 패턴
정의 : 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴


특징 


-	하나의 인스턴스를 만들어 놓고 해당 인스턴스를 다른 모듈들이 공유하며 사용한다.
-	보통, 데이터베이스 연결 모듈에 많이 사용합니다.


장점

-	사용하기가 쉽고 실용적이다.
-	비용이 줄어든다.

단점

-	모듈 간의 결합을 강하게 만들 수 있다. => *의존성 주입을 통해 결합을 약하게 가능
-	싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반을 구현하는 패턴이므로 각 테스트마다 ‘독립적인’ 인스턴스를 만들기가 어렵다.

#### ✔️의존성 주입(DI : Dependancy Injection )  🔎[참고](https://tecoble.techcourse.co.kr/post/2021-04-27-dependency-injection/)
클래스 간, 모듈 간 결합도를 느슨하게 하기 위해 외부에서 의존성 주입자 (dependency injector)를 생성하여 주입하는 것


장점


-	결합도가 약해져, 리펙토링이 쉬워진다. 
-	애플리케이션 의존성 방향이 일관되고, 애플리케이션을 쉽게 추론할 수 있다.


단점
-	클래스 수가 늘어나 복잡성이 증가한다.


원칙


“상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 한다.”

### 1.1.2 팩토리 패턴
정의: 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대(객체 생성 부분을 떼어내 추상화)를 결정하고, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴이다.


특징 
-	상위 클래스와 하위 클래스가 분리되기 때문에 느슨한 결합을 가지며 더 많은 유연성
을 갖게 된다.
-	객체 생성 로직이 따로 떼어져 있기 때문에 리펙로링 시 유지보수성이 증가된다.

### 1.1.3 전략 패턴
정의: 객체의 행위를 바꾸고 싶은 경우 ‘직접’ 수정하지 않고 전략이라고 부르는 ‘캡슐화한 알고리즘’을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴이다.


### 1.1.4 옵저버 패턴
정의: 주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 디자인 패턴
#### ✔️옵저버
이 객체의 상태 변화에 따라 전달되는 메서드 등을 기반으로 ‘추가 변화 사항’이 생기는 객체들
### 1.1.5 프록시 패턴과 프록시 서버
**프록시 패턴 정의 **

프록시 패턴은 대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞 단의 인터페이스 역할을 하는 디자인 패턴이다.


**프록시 서버 정의**

프록시 서버는 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램이다.


### 1.1.6 이터레이터 패턴
정의: 이터레이터를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴


### 1.1.7 노출모듈 패턴
정의: 즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴을 말한다.

특징
- 자바스크립트는 private 나 public 같은 접근 제어자가 존재하지 않고 전역 범위에서 스크립트가 실행된다. 그렇기 때문에 노출모듈 패턴을 통해 접근 제어자를 구현하기도 한다.
```
const pukuba = (() => {
  const a = 1          //a와 b 는 다른 모듈에서 사용할 수 없는 변수나 함수 : private 범위
  const b = () => 2
  const public = {
    c: 2,              // c와 d 는 다른 모듈에서 사용할 수 있는 변수나 함수 : public 범위
    d: () =>3
    }
    return public 
})()
console.log(pukuba)
console.log(pukuba.a)
```

### 1.1.8 MVC 패턴

정의: Model, View, Controller 로 이루어진 디자인 패턴


특징

- 개발 프로세스에서 각각의 구성 요소에만 집중해서 개발할 수 있음.
- 재사용성과 확장성이 용이하다.


#### 모델
애플리케이션의 데이터인 데이터 베이스, 상수, 변수
#### 뷰
사용자 인터페이스 요소, 모델을 기반으로 사용자가 볼 수 있는 화면
#### 컨트롤러
하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할을 하며 이벤트 등 메인 로직을 담당

### 1.1.8 MVP 패턴

정의: Model, View, Presenter 로 이루어진 디자인 패턴


특징
- 뷰와 프레젠터가 일대일 관계이기 때문에 MVC 패턴보다 더 강한 결합을 지녔다.
- MVC 패턴으로부터 파생되어 C(컨트롤러)가 P(프레젠터)로 교체된 패턴이다.


### 1.1.10 MVVM 패턴
정의: Model, View, View Model 로 이루어진 디자인 패턴


특징
- 뷰모델은 뷰를 더 추상화한 계층이며, **커맨드와 데이터 바인딩**을 가지는 것이 특징이다.
- 뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원하며 UI 를 별도의 코드 수정 없이 재사용할 수 있고 단위 테스팅하기 쉽다.
- MVC 패턴으로부터 파생되어 C(컨트롤러)가 VM(뷰 모델)로 교체된 패턴이다.
> **커맨드**


> 여러가지 요소에 대한 처리를 하나의 액션으로 처리할 수 있게 하는 기법


> **데이터 바인딩**


> 화면에 보이는 데이터와 웹 브라우저의 메모리 데이터를 일치시키는 기법으로, 뷰모델을 변경하면 뷰가 변경된다.

## 1.2 프로그래밍 패러다임
------------------------
#### ✔️프로그래밍 패러다임이란? 
프로그래머에게 프로그래밍의 관점을 갖게 해주는 역할을 하는 개발 방법론이다.
#### ✔️프로그래밍 패러다임 분류
- 선언형
  - 함수형
- 명령형
  - 객체지향형
  -  절차지향형

### 1.2.1 선언형과 함수형 프로그래밍
#### 선언형 프로그래밍 정의: '무엇을' 풀어내는가에 집중하는 패러다임 "프로그램은 함수로 이루어진 것이다."
#### 함수형 프로그래밍 정의: 선언형 프로그래밍의 일종이다. 작은 '**순수 함수**' 들을 블록처럼 쌓아 로직을 구현하고 '**고차 함수**'를 통해 재사용성을 높이는 프로그래밍 패러다임

```
const ret = [1,2,3,4,5,11,12]
.reduce((max, min) => num > max ? num: max, 0)    // reduce() 는 '배열' 만 받아서 누적한 결괏값을 반환하는 순수 함수
console.log(ret)   //12
```

>**순수함수**


>출력이 입력에만 의존하는 것을 의미


>**고차 함수**


>함수가 함수를 값처럼 매개변수로 받아 로직을 생성할 수 있는 것을 말한다.



### 1.2.2 객체지향 프로그래밍
#### 정의: 객체들의 집합으로 프로그램의 상호 작용을 표현하며 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식을 말한다.
#### 특징
>**추상화**


>복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것을 의미


>**캡슐화**


>객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것을 의미


>**상속성**


>상위 클래스의 특성을 하위 클래스가 이어받아서 재사용하거나 추가, 확장하는 것을 의미


>**다형성**


>하나의 메서드나 클래스가 다양한 방법으로 동작하는 것을 말한다. ex) **오버로딩, 오버라이딩**




✔️오버로딩: 같은 이름을 가진 메서드를 여러 개 두는 것 => 정적 다형성


✔️오버라이딩: 상위 클래스로부터 상속받은 메서드를 하위 클래스가 재정의하는 것을 의미 => 동적 다형성


#### 설계 원칙: SOLID 원칙


>**S: 단일 책임 원칙**


>**O: 개방 - 폐쇄 원칙 **


>**L: 리스코프 치환 원칙 **


>**I: 인터페이스 분리 원칙 **


>**D: 의존 역전 원칙 **



### 1.2.3 절차형 프로그래밍
#### 정의 : 로직이 수행되어야 할 연속적인 계산 과정으로 이루어져 있다.
#### 특징
- 일이 진행되는 방식으로 그저 코드를 구현하기만 하면 되기 때문에 코드의 가독성이 좋으며 실행 속도가 빠르다.
- 계산이 많은 작업 등에 쓰인다.
- 모듈화가 어려워 유지 보수성이 떨어진다는 단점이 있다.

### 1.2.4 패러다임의 혼합
❗ 하나의 패러다임을 기반으로 통일하여 서비스를 구축하는 것도 좋은 생각이지만 여러 패러다임을 조합하여 상황과 맥락에 따라 패러다임 간의 장점만 취해 개발하는 것이 좋다.


